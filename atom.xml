<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霖溦之境</title>
  
  <subtitle>霖溦的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/kukumaluCN/kukumaluCN.github.io/"/>
  <updated>2018-11-16T09:14:58.293Z</updated>
  <id>https://github.com/kukumaluCN/kukumaluCN.github.io/</id>
  
  <author>
    <name>霖溦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于performSelector的一点注意</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/11/16/%E5%85%B3%E4%BA%8EperformSelector%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/11/16/关于performSelector的一点注意/</id>
    <published>2018-11-16T08:15:02.000Z</published>
    <updated>2018-11-16T09:14:58.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刚在群里看到这样一段代码，很有意思：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的执行结果会是什么呢？<br>是打印“1、2”，还是“1、3、2”，或者是“1、2、3”？</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="1-问题探究"><a href="#1-问题探究" class="headerlink" title="1.问题探究"></a>1.问题探究</h2><p>这其实是一道很有意思的面试题，内容涉及runloop这个知识点。<br><strong>答案是只打印：“1、2”。</strong><br>原因群里的大神给了解答：</p><blockquote><p>因为<code>[self performSelector:@selector(test) withObject:nil afterDelay:.0]</code>实际在runloop里面，是一个定时器，但是因为在子线程，runloop是默认没有开启的。</p></blockquote><p>这除了涉及runloop，还有多线程的问题，有兴趣的可以深究。<br>其实我们只要仔细阅读苹果API的注释，就能解释这个问题：</p><p><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-performSelectorafterDelay.png" alt="performSelectorafterDelay"></p><p>想要执行<code>-test</code>方法，注释里也提供了解决办法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>其实针对上述的逻辑，更简单的是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h2 id="2-引发的思考"><a href="#2-引发的思考" class="headerlink" title="2.引发的思考"></a>2.引发的思考</h2><h3 id="2-1-不要懒"><a href="#2-1-不要懒" class="headerlink" title="2.1.不要懒"></a>2.1.不要懒</h3><p>之所以要提上述的问题，除了这个面试的“考点”，其实在平时的开发过程中也要注意自己代码的严谨性。<br>我发现自己在阅读别人的代码时，就见过同样的写法，其实甚至那些比较有名的三方库，例如“<code>YYText</code>”中，也有类似的代码存在：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>写这段代码的人只是为了通过selector来立刻执行某一方法，<code>delay</code>并不是他们的需求，为什么还要“多此一举”呢？<br>这里一大部分原因，很可能还是因为我们被xcode的自动提示给“惯坏了”：</p><p><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-perform自动提示.png" alt="perform自动提示"></p><p>毕竟当你写代码时，罗列的一堆提示，只是按照API相似度排列出来的，很多人看到了自己需要的就直接回车了，不需要<code>delay</code>，直接写0，就行了，反正“都一样”……<br>其实这是一个误区，看起来很相似的API，实则并不一样，而且很不一样：</p><ul><li><p>我们常用的这个perform，是<code>NSObject.h</code>这个头文件下的方法：<br><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-perform不一样1.png" alt="perform不一样1"></p></li><li><p>可以delay的，是<code>NSRunLoop.h</code>下的方法：<br><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-perform不一样2.png" alt="perform不一样2"></p></li><li><p>而之前提到的回调主线程的，是<code>NSThread.h</code>里的方法：<br><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-perform不一样3.png" alt="perform不一样3"></p></li></ul><p>虽然他们都是NSObject的方法或者是分类补充方法，但实际上，是隶属于不同的模块的。</p><h3 id="2-2-更深刻的原因"><a href="#2-2-更深刻的原因" class="headerlink" title="2.2.更深刻的原因"></a>2.2.更深刻的原因</h3><p>但是“<code>YYText</code>”的作者应该是不会犯这种低级错误的，那就应该还有更深刻的原因了：</p><p><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-PerformSelectormacausealeak.png" alt="PerformSelectormacausealeak"></p><p>我们很多人应该总是会被上述的警告所困扰，大多数人的解决方式，就是利用类似相面的方式去屏蔽警告，这种做法虽然简单，但实际是有风险的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line"><span class="comment">//code</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>其实除了利用<code>NSInvocation</code>那种比较高端的方式，更多的情况下，在方法没有返回值时，或者我们不需要返回值时，我们可以用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>这种方式去避免警告的，看上面的那三个对比你就会发现，后两类API，同样是<code>performSelector</code>，却没有返回值，这其实也是有官方注释的依据的：</p><p><img src="http://pcriprrao.bkt.clouddn.com/2018-11-16-PerformSelector官方注释2.png" alt="PerformSelector官方注释2"></p><p>但其实你也要注意到了，官方的建议还是很严谨的，是用<code>performSelectorOnMainThread</code>，而不是delay0的方式，至于原因，我们又回到了文章一开头的讨论了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面看似无意义的探究，我们还是可以得到很深刻的教训的：“苹果霸霸”还是很严谨的，所看API的注释，总是没错的。</p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/11/16/%E5%85%B3%E4%BA%8EperformSelector%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;刚在群里看到这样一段代码，很有意思：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="performSelector" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/performSelector/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods的版本升级和降级</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/09/20/Cocoapods%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/09/20/Cocoapods的版本升级和降级/</id>
    <published>2018-09-20T08:17:33.000Z</published>
    <updated>2018-09-20T08:55:26.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>在平时开发中，有时可能会遇到Cocoapods的版本的问题，我们实际使用的版本可能会因为过低而导致各种问题，这时需要升级，有时又会因为某个开源库不支持最新的Cocoapods版本而不得不降级我们本地的Cocoapods。</p><ul><li>1.升级</li></ul><p>升级比较简单，实际命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo gem install -n /usr/local/bin cocoapods -v 1.5.3</span><br></pre></td></tr></table></figure><p><code>-v</code>后面是版本号，当前Cocoapods的release版为1.5.3。<br>输入密码之后即可执行升级操作。<br>升级结束后，可以查看下当前的pod版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//执行命令查看版本信息</span><br><span class="line"><span class="meta">$</span> pod --version</span><br><span class="line">//输出的版本号是最新的</span><br><span class="line">1.5.3</span><br></pre></td></tr></table></figure><ul><li>2.切换Ruby源</li></ul><p>执行上述命令时，可能会遇到如下的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  Could not find a valid gem 'cocoapods' (= 1.5.3), here is why:</span><br><span class="line">          Unable to download data from https://gems.ruby-china.org/ - bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz)</span><br></pre></td></tr></table></figure><p>这是因为之前在配置Cocoapods时，本地的源设置的问题，这篇文章写下时，RubyGems的国内镜像已经变成了：<code>https://gems.ruby-china.com</code>。<br>我们需要手动切换一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查询本地源的列表</span><br><span class="line"><span class="meta">$</span> gem sources -l</span><br><span class="line">//删除已经不能使用的源</span><br><span class="line"><span class="meta">$</span> gem sources --remove https://gems.ruby-china.org/</span><br><span class="line">//添加最新的源</span><br><span class="line"><span class="meta">$</span> gem sources -a https://gems.ruby-china.com</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//再次查询</span><br><span class="line"><span class="meta">$</span> gem sources -l</span><br><span class="line"></span><br><span class="line">//可以看下如下信息，表示切换成功：</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://gems.ruby-china.com</span><br></pre></td></tr></table></figure><ul><li>3.降级</li></ul><p>和执行升级操作一样，比如想要安装1.5.0版本，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo gem install -n /usr/local/bin cocoapods -v 1.5.0</span><br></pre></td></tr></table></figure><p>提示安装成功后，再次查询版本号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//执行命令查看版本信息</span><br><span class="line"><span class="meta">$</span> pod --version</span><br><span class="line">//输出的版本号依旧是最新的</span><br><span class="line">1.5.3</span><br></pre></td></tr></table></figure><p>这是因为本地安装了多个版本的cocoapods，默认使用最新的版本，想要切换低版本，可以执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//执行卸载命令</span><br><span class="line"><span class="meta">$</span> sudo gem uninstall cocoapods</span><br><span class="line"></span><br><span class="line">//提示卸载哪一版本，并列出本地安装过的所有版本</span><br><span class="line">Select gem to uninstall:</span><br><span class="line"> 1. cocoapods-1.1.1</span><br><span class="line"> 2. cocoapods-1.2.1</span><br><span class="line"> 3. cocoapods-1.3.1</span><br><span class="line"> 4. cocoapods-1.5.0</span><br><span class="line"> 5. cocoapods-1.5.3</span><br><span class="line"> 6. All versions</span><br><span class="line"></span><br><span class="line">//输入5，卸载最新的那一版本</span><br><span class="line"><span class="meta">&gt;</span> 5</span><br><span class="line"></span><br><span class="line">//提示卸载成功</span><br><span class="line">Successfully uninstalled cocoapods-1.5.3</span><br><span class="line"></span><br><span class="line">//查询版本号，可以看到此时使用的是1.5.0，也就是当前最新的版本了</span><br><span class="line"><span class="meta">$</span> pod --version</span><br><span class="line">1.5.0</span><br></pre></td></tr></table></figure><p>除了上述的方法，还可以:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//列出所有信息</span><br><span class="line"><span class="meta">$</span> gem list</span><br><span class="line"></span><br><span class="line">//找到此项</span><br><span class="line">cocoapods (1.1.1, 1.2.1, 1.3.1, 1.5.0, 1.5.3)</span><br><span class="line"></span><br><span class="line">//移除指定版本cocoapods</span><br><span class="line"><span class="meta">$</span> sudo gem uninstall cocoapods -v 1.5.3</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://segmentfault.com/q/1010000004207378/a-1020000004207497" target="_blank" rel="noopener">安装CocoaPods 出现这样的问题</a></li><li><a href="https://blog.csdn.net/hsf_study/article/details/69945473" target="_blank" rel="noopener">升级 Cocoapods 到1.2.0指定版本，降低版本及卸载</a></li><li><a href="https://blog.csdn.net/focusjava/article/details/51325802" target="_blank" rel="noopener">iOS开发中如何管理多个版本的Cocoapods、gem</a></li><li><a href="https://www.cnblogs.com/ningmengcao-ios/p/5882505.html" target="_blank" rel="noopener">cocoapods 卸载,重装,高版本的使用</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/09/20/Cocoapods的版本升级和降级/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/09/20/Cocoapods的版本升级和降级/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;在平时开发中，有时可能会遇到Cocoapods的版本的问题，我们实际使用的版本可能会因为过低而导致各种问题，这时需要升级，有
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>随机内容字符串</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/13/%E9%9A%8F%E6%9C%BA%E5%86%85%E5%AE%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/13/随机内容字符串/</id>
    <published>2018-08-13T05:51:43.000Z</published>
    <updated>2018-08-13T09:24:32.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们再平时开发过程中，可能需要一些随机内容的字符串用于测试，例如：任意长度的内容字符串，测试我们的tableView的cell的高度自适应，这类测试有利于发现一些隐藏的bug。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-随机长度的字符串"><a href="#1-随机长度的字符串" class="headerlink" title="1.随机长度的字符串"></a>1.随机长度的字符串</h2><p>比较简单的做法是，有一个固定的字符串，我们去取其随机长度的子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;测试字符串&quot;;</span><br><span class="line">NSString *randomStr = [str substringToIndex:arc4random_uniform((uint32_t)(str.length))];</span><br></pre></td></tr></table></figure><h2 id="2-利用CCRandomGenerateBytes生成随机字符串"><a href="#2-利用CCRandomGenerateBytes生成随机字符串" class="headerlink" title="2.利用CCRandomGenerateBytes生成随机字符串"></a>2.利用CCRandomGenerateBytes生成随机字符串</h2><p>这个方法参考这里：<a href="https://blog.csdn.net/u012198553/article/details/78707197" target="_blank" rel="noopener">ios CCRandomGenerateBytes 生成定长随机字符串</a><br>可以生成任意长度的，随机的字母和数字组合的字符串，他本质是用作生成随机密钥的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//利用CCRandomGenerateBytes生成随机字符串</span><br><span class="line">+ (NSString *)jxt_randomStringWithLength:(size_t)length</span><br><span class="line">&#123;</span><br><span class="line">    if (length &lt; 1) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    length = length*0.5;</span><br><span class="line">    unsigned char digest[length];</span><br><span class="line">    CCRNGStatus status = CCRandomGenerateBytes(digest, length);</span><br><span class="line">    if (status == kCCSuccess) &#123;</span><br><span class="line">        return [self private_jxt_stringFrom:digest length:length];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将bytes转为字符串</span><br><span class="line">+ (NSString *)private_jxt_stringFrom:(unsigned char *)digest length:(size_t)length</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        [string appendFormat:@&quot;%02x&quot;,digest[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-指定位数随机数的生成"><a href="#3-指定位数随机数的生成" class="headerlink" title="3.指定位数随机数的生成"></a>3.指定位数随机数的生成</h2><p>这个一般用于验证码等随机密码的业务场合，常用的是生成4位或6位的随机数组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6位随机数</span><br><span class="line">[NSString stringWithFormat:@&quot;%06d&quot;, arc4random() % 1000000];</span><br><span class="line">//4位随机数</span><br><span class="line">[NSString stringWithFormat:@&quot;%04d&quot;, arc4random() % 10000];</span><br></pre></td></tr></table></figure><p>上述的算法比较简单，但是当我们需要长度更大的随机数字时，这个算法就有局限了，因为arc4random()的取值范围是0～4294967295，针对这个问题，我们可以改进一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)jxt_randomDigitsStringWithLength:(NSUInteger)length</span><br><span class="line">&#123;</span><br><span class="line">    NSString *randomDigits = @&quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">        randomDigits = [randomDigits stringByAppendingFormat:@&quot;%d&quot;, (arc4random() % 10)];</span><br><span class="line">    &#125;</span><br><span class="line">    return randomDigits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上述算法在性能上是比不上先前的两个的，所以要根据需求取舍。</p><p><strong>Demo详见：<a href="https://github.com/kukumaluCN/JXT_iOS_Demos/tree/master/RandomStringForTest">RandomStringForTest</a></strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u012198553/article/details/78707197" target="_blank" rel="noopener">ios CCRandomGenerateBytes 生成定长随机字符串</a></p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/13/随机内容字符串/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/13/随机内容字符串/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们再平时开发过程中，可能需要一些随机内容的字符串用于测试，例如：任意长度的内容字符串，测试我们的tableView的cell的高度自适应，
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="随机数" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>用结构体初始化大量布局常数</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/09/%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E9%87%8F%E5%B8%83%E5%B1%80%E5%B8%B8%E6%95%B0/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/09/用结构体初始化大量布局常数/</id>
    <published>2018-08-09T01:59:14.000Z</published>
    <updated>2018-08-09T03:23:17.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在平时UI适配开发中，可能会用到Masonry或者手写布局，在这些布局中，经常会用到一些常量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)addSubviewsConstraints</span><br><span class="line">    [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.top.mas_equalTo(self.view).offset(10);</span><br><span class="line">        make.width.height.mas_equalTo(100);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    self.myView.frame = CGRectMake(10, 10, 100, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只是两个固定值的例子，在Masonry中，<code>offset(10)</code>是一个间距值，对应手写frame布局就是<code>origin.x</code>和<code>origin.y</code>，这些值很可能是一些常数，一般不会更改，不过，如果肆意任这些常数散落在代码中，对于后期维护，可能会带来不小的麻烦。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="1-一般做法"><a href="#1-一般做法" class="headerlink" title="1.一般做法"></a>1.一般做法</h2><p>针对上述的麻烦，一般的做法是，布局时，统一初始化一些常数，后期维护，只是更改这些常数就好了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//布局常数</span><br><span class="line">CGFloat myViewLeftGap = 10, myViewTopGap = 10;</span><br><span class="line">CGSize myViewSize = CGSizeMake(100, 100);</span><br><span class="line">//Masonry</span><br><span class="line">- (void)addSubviewsConstraints</span><br><span class="line">    [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.mas_equalTo(self.view).offset(myViewLeftGap);</span><br><span class="line">        make.top.mas_equalTo(self.view).offset(myViewTopGap);</span><br><span class="line">        make.size.mas_equalTo(myViewSize);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">//frame</span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    self.myView.frame = CGRectMake(myViewLeftGap, myViewTopGap, myViewSize.width, myViewSize.height);</span><br><span class="line">    //或者</span><br><span class="line">    self.myView.frame = (CGRect)&#123;myViewLeftGap, myViewTopGap, myViewSize&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做看似麻烦，但是后期改起来，或者是调试bug时，我们只要关心常量的初始化部分就好了，不用再去看对应的布局代码，这就很省心了。</p><h2 id="2-使用结构体统一管理的优化"><a href="#2-使用结构体统一管理的优化" class="headerlink" title="2.使用结构体统一管理的优化"></a>2.使用结构体统一管理的优化</h2><p>上面的做法相对已经好了很多，但是，对于复杂的页面，页面的视图元素比较多时，这种方法会显得很臃肿，你要在布局代码前，初始化大量的常量，这种做法很不好，而且，在系统执行布局刷新时，对应的常数，再次被初始化了一遍，即便值没有更改，这就造成了不必要的开销。<br>对于这个问题，我们这里引入了结构体，结构体在iOS开发中，一般会很少使用，但其实系统中有很多例子，之前提到的<code>CGRect</code>和<code>CGSize</code>都是结构体这种数据结构。<br>下面是利用结构体对之前的做法的一种优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 声明布局常量结构体</span><br><span class="line"> */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    CGFloat myViewLeftGap;</span><br><span class="line">    CGFloat myViewTopGap;</span><br><span class="line">    CGSize myViewSize;</span><br><span class="line">&#125; MyLayoutConsts;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) UIView * myView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">&#123;</span><br><span class="line">    MyLayoutConsts _layout; //结构体全局变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Life Cycle</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //初始化结构体，结构体的初始化有很多种方式，我采用的这种，会显得比较清晰，便于修改</span><br><span class="line">    _layout = (MyLayoutConsts)&#123;</span><br><span class="line">        .myViewLeftGap = 20,</span><br><span class="line">        .myViewTopGap = 20,</span><br><span class="line">        .myViewSize = CGSizeMake(100, 100)</span><br><span class="line">    &#125;;</span><br><span class="line">    [self.view addSubview:self.myView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - UI</span><br><span class="line">- (void)viewWillLayoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillLayoutSubviews];</span><br><span class="line">    </span><br><span class="line">    self.myView.frame = (CGRect)&#123;_layout.myViewLeftGap, _layout.myViewTopGap, _layout.myViewSize&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Lazy Load</span><br><span class="line">- (UIView *)myView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_myView) &#123;</span><br><span class="line">        _myView = [[UIView alloc] initWithFrame:CGRectZero];</span><br><span class="line">        _myView.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _myView;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里使用<code>MyLayoutConsts _layout;</code>而没有使用属性，是为了节省调用get方法的开销，本质是一样的。<br>当然，这里要注意，<code>_layout.myViewLeftGap</code>语句本质上是<code>selg-&gt;_layout.myViewLeftGap</code>，所以要注意在block中的循环引用的问题。</p><p><strong>Demo详见<a href="https://github.com/kukumaluCN/JXT_iOS_Demos/tree/master/StructForLayoutDemo">StructForLayoutDemo</a></strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/qinqi376990311/article/details/73457506" target="_blank" rel="noopener">iOS开发中结构体的另一种“初始化方法”</a></li><li><a href="https://blog.csdn.net/github_26672553/article/details/50382188/" target="_blank" rel="noopener">结构体的4种初始化方式</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/09/用结构体初始化大量布局常数/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/09/用结构体初始化大量布局常数/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在平时UI适配开发中，可能会用到Masonry或者手写布局，在这些布局中，经常会用到一些常量，例如：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="结构体" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>一台电脑管理多个Git账户和SSH KEY</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/02/%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAGit%E8%B4%A6%E6%88%B7%E5%92%8CSSH-KEY/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/</id>
    <published>2018-08-02T12:26:27.000Z</published>
    <updated>2018-08-05T11:35:18.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时开发过程中可能遇到这样的问题，就是在进行公司的项目开发时要用公司的git账号，以及对应的git仓库，比如gitlab的；对于个人的开源项目，又会有自己的git账号，以及对应的git仓库，比如github或者码云（gitee）。<br>这时就会遇到多账户提交时的冲突问题，以及对应的多个ssh key的管理的问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-多个ssh-key的管理"><a href="#1-多个ssh-key的管理" class="headerlink" title="1.多个ssh key的管理"></a>1.多个ssh key的管理</h2><h3 id="1-1-ssh-key的创建"><a href="#1-1-ssh-key的创建" class="headerlink" title="1.1.ssh key的创建"></a>1.1.ssh key的创建</h3><p>假如有两个git账户，分别是<a href="mailto:`github@example.com" target="_blank" rel="noopener">`github@example.com</a><code>和</code><a href="mailto:gitee@example.com" target="_blank" rel="noopener">gitee@example.com</a>`。为了提交git，我们需要设置对应的ssh key，ssh key具体其在对应平台的配置方法比较简单，本文不再详述，可参考对应的资料，这里只是ssh key的创建及管理。<br>在终端输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "github@example.com"</span><br></pre></td></tr></table></figure><p>终端提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/XXX/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>此时直接回车，就会在<code>/Users/XXX/.ssh/</code>路径下，创建一个名为<code>id_rsa</code>的公钥，这个并不是我们想要的，因为这里要设计多个ssh key的管理，这个命名没有任何特征。</p><p>在终端中输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /Users/XXX/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>表示这个是github平台的key，之后根据终端提示，输入并确认密码，就可以生成了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /Users/XXX/.ssh/id_rsa_github.</span><br><span class="line">Your public key has been saved in /Users/XXX/.ssh/id_rsa_github.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>同理，另一个ssh key的创建流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "gitee@example.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): </span><br><span class="line"><span class="meta">$</span> /Users/XXX/.ssh/id_rsa_gitee</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /Users/XXX/.ssh/id_rsa_gitee.</span><br><span class="line">Your public key has been saved in /Users/XXX/.ssh/id_rsa_gitee.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="1-2-配置ssh代理"><a href="#1-2-配置ssh代理" class="headerlink" title="1.2.配置ssh代理"></a>1.2.配置ssh代理</h3><p>创建好了上面的多个ssh key就可以开始管理他们了。<br>在终端中输入如下命令，查询系统ssh key的代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -l</span><br></pre></td></tr></table></figure><p>如果系统已经设置了代理，需要删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -D</span><br><span class="line">All identities removed.</span><br></pre></td></tr></table></figure><p>如果提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> exec ssh-agent bash</span><br></pre></td></tr></table></figure><p>接下来添加刚才创建的ssh key的私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一个</span><br><span class="line"><span class="meta">$</span> ssh-add ~/.ssh/id_rsa_github</span><br><span class="line">Enter passphrase for /Users/XXX/.ssh/id_rsa_github: </span><br><span class="line">Identity added: /Users/XXX/.ssh/id_rsa_github (/Users/XXX/.ssh/id_rsa_github)</span><br><span class="line"></span><br><span class="line">//第二个</span><br><span class="line"><span class="meta">$</span> ssh-add ~/.ssh/id_rsa_gitee</span><br><span class="line">Enter passphrase for /Users/XXX/.ssh/id_rsa_gitee: </span><br><span class="line">Identity added: /Users/XXX/.ssh/id_rsa_gitee (/Users/XXX/.ssh/id_rsa_gitee)</span><br></pre></td></tr></table></figure><h3 id="1-3-添加公钥"><a href="#1-3-添加公钥" class="headerlink" title="1.3.添加公钥"></a>1.3.添加公钥</h3><p>其实就是将对应的.pub中的内容，复制到对应平台的ssh key管理栏目中，不同的平台，位置不同，可以去对应的个人中心的设置中查看，很容易找到。</p><h3 id="1-4-配置文件config"><a href="#1-4-配置文件config" class="headerlink" title="1.4.配置文件config"></a>1.4.配置文件config</h3><p>在/.ssh目录下创建config配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim ~/.ssh/config</span><br></pre></td></tr></table></figure><p>熟悉vim的可以直接在终端中编辑这个config文件，不熟悉的，打开指定目录下新创建的config文件，直接文本编辑即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> github配置</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> gitee配置</span><br><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_gitee</span><br></pre></td></tr></table></figure><p>编辑保存后，再次查看ssh key的代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -l</span><br></pre></td></tr></table></figure><p>如果看到如下，说明设置成功了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2048 SHA256:............ /Users/XXX/.ssh/id_rsa_github (RSA)</span><br><span class="line">2048 SHA256:............ /Users/XXX/.ssh/id_rsa_gitee (RSA)</span><br></pre></td></tr></table></figure><h3 id="1-5-验证ssh-key"><a href="#1-5-验证ssh-key" class="headerlink" title="1.5.验证ssh key"></a>1.5.验证ssh key</h3><p>终端中输入如下验证命令，如果返回如下，说明配置成功了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh -T git@github.com</span><br><span class="line">Hi XXXXXX! You've successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ssh -T git@gitee.com</span><br><span class="line">Hi XXXXXX! You've successfully authenticated, but Gitee.com does not provide shell access.</span><br></pre></td></tr></table></figure><p>如果遇到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission denied (publickey)</span><br></pre></td></tr></table></figure><p>就是之前的公钥设置的问题，需要去对应的平台检查下ssh key公钥是否设置成功。<br>至此，ssh key的配置管理就结束了。</p><h2 id="2-多个git账户的提交问题"><a href="#2-多个git账户的提交问题" class="headerlink" title="2.多个git账户的提交问题"></a>2.多个git账户的提交问题</h2><p>我们大多数人都会使用第三方工具进行git提交，比如source tree之类的，这些工具在提交时，如果不对对应的git仓库进行专门的配置，会默认走git的全局配置，也就是会用默认的全局配置的账户进行git提交。一不小心，就会用我们私人的账户，进行了公司项目的git提交，生成了对应的提交记录，也有可能因为权限问题，导致直接提交失败。<br>这时，我们需要对不同的仓库，进行对应的配置。</p><h3 id="2-1-检查全局配置"><a href="#2-1-检查全局配置" class="headerlink" title="2.1.检查全局配置"></a>2.1.检查全局配置</h3><p>在终端中，分别输入如下命令，可以检查目前电脑中的git的全局配置信息，如果没有返回，说明没有全局配置，如果有，就可以看到对应的默认的账户是那个了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.name</span><br><span class="line"><span class="meta">$</span> git config --global user.email</span><br></pre></td></tr></table></figure><p>为了避免麻烦，我们可以取消全局配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global --unset user.name</span><br><span class="line"><span class="meta">$</span> git config --global --unset user.email</span><br></pre></td></tr></table></figure><h3 id="2-2-全局配置和局部配置"><a href="#2-2-全局配置和局部配置" class="headerlink" title="2.2.全局配置和局部配置"></a>2.2.全局配置和局部配置</h3><p>此时已经取消了电脑中默认的git全局配置信息，此时进行git提交，会报对应的找不到账户信息的错误。<br>我们可以cd到对应的git仓库的根目录下，执行局部git配置命令。比如<code>/Users/XXX/github/DemoProject</code>是一个在github平台托管的本地git仓库的根目录，我们可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /Users/XXX/github/DemoProject</span><br><span class="line"><span class="meta">$</span> git config user.name</span><br><span class="line"><span class="meta">$</span> git config user.email</span><br></pre></td></tr></table></figure><p>如果返回均为空，说明没有进行过局部配置，可以分别配置github的账户名和邮箱：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config user.name "github账户名"</span><br><span class="line"><span class="meta">$</span> git config user.email "github@example.com"</span><br></pre></td></tr></table></figure><p>同理，在不同的git仓库下，可以分别配置不同平台的git账户名和git邮箱。这虽然看起来麻烦，不过，只要设置完成，之后只要不再更改对应的git仓库的路径，就不需要再更换配置了。<br><strong>而且，即便我们没有取消默认的全局git配置，在进行了局部配置后，后者的优先级会更高。</strong></p><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --list</span><br></pre></td></tr></table></figure><p>可以查看查看当前仓库的具体配置信息，在当前仓库目录下查看的配置是全局配置+当前项目的局部配置，<strong>使用的时候会优先使用当前仓库的局部配置，如果没有，才会去读取全局配置。</strong></p><h3 id="2-3-hexo部署时的git提交问题"><a href="#2-3-hexo部署时的git提交问题" class="headerlink" title="2.3.hexo部署时的git提交问题"></a>2.3.hexo部署时的git提交问题</h3><p>因为我们先前取消了电脑中的git全局配置，hexo在部署发布时，可能遇到如下问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email "you@example.com"</span><br><span class="line">  git config --global user.name "Your Name"</span><br><span class="line"></span><br><span class="line">to set your account's default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br></pre></td></tr></table></figure><p>不知道是不是因为hexo必须要求读取全局配置，设置了几个文件夹的局部git配置，均无效，只好又恢复了全局配置，也就是对应的github的账户信息，因为之前提到过，局部配置的优先级大于全局配置，所以不用担心账户冲突的问题，只要设置好对应仓库的局部配置信息，就不用担心全局配置的存在。<br>当然，这只是折中的方案，如果有人知道如何配置hexo仓库的局部配置信息，欢迎指教。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/wwmusic/article/details/51027458" target="_blank" rel="noopener">一台电脑如何管理多个SSH KEY</a></li><li><a href="https://www.jianshu.com/p/a869072a0092" target="_blank" rel="noopener">同一台电脑关于多个SSH KEY管理</a></li><li><a href="https://blog.csdn.net/yanzhenjie1003/article/details/69487932?locationNum=4&amp;fps=1" target="_blank" rel="noopener">Git管理多个SSH密钥，Git多帐号配置</a></li><li><a href="http://www.cnblogs.com/zichi/p/4704824.html" target="_blank" rel="noopener">如何配置多个ssh key</a></li><li><a href="https://blog.csdn.net/baidu_35738377/article/details/54580156" target="_blank" rel="noopener">Git配置多账号登录不同项目</a></li><li><a href="https://blog.csdn.net/luohai859/article/details/50679859" target="_blank" rel="noopener">Git全局配置和单个仓库的用户名邮箱配置</a></li><li><a href="https://www.cnblogs.com/chenwolong/p/GIT.html" target="_blank" rel="noopener">GIT 常用命令</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时开发过程中可能遇到这样的问题，就是在进行公司的项目开发时要用公司的git账号，以及对应的git仓库，比如gitlab的；对于个人的开源项
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Git" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/Git/"/>
    
    
      <category term="Git" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/Git/"/>
    
      <category term="SSH KEY" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/SSH-KEY/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods中PBXSourcesBuildPhase unknown UUID的错误解决</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods%E4%B8%ADPBXSourcesBuildPhase-unknown-UUID%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/</id>
    <published>2018-08-01T09:07:01.000Z</published>
    <updated>2018-08-02T12:29:23.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>在执行<code>pod install</code>命令时，出现了如下的警告：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[!] `&lt;PBXResourcesBuildPhase UUID=`XXX`&gt;` </span><br><span class="line">attempted to initialize an object with an </span><br><span class="line">unknown UUID. `XXX` for attribute: `files`. </span><br><span class="line">This can be the result of a merge and  the </span><br><span class="line">unknown UUID is being discarded.</span><br></pre></td></tr></table></figure></p><p>解决方式如下：</p><ul><li>1.打开项目-&gt;Target-&gt;General-&gt;Linked Frameworks and Libraries，选中libpods-XXX.a，XXX是指你的项目名称，点“-”删除。</li><li>2.退出Xcode</li><li>3.重新执行pod install</li></ul><p><img src="http://pcriprrao.bkt.clouddn.com/2018-08-01-libpoda.png" alt="libpoda"></p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;在执行&lt;code&gt;pod install&lt;/code&gt;命令时，出现了如下的警告：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods中的Smart quotes were detected...警告</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods%E4%B8%AD%E7%9A%84Smart-quotes-were-detected-%E8%AD%A6%E5%91%8A/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/</id>
    <published>2018-08-01T08:46:36.000Z</published>
    <updated>2018-08-01T09:16:58.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>在执行<code>pod install</code>命令时，出现了如下的警告：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[!] Smart quotes were detected and ignored in </span><br><span class="line">your Podfile. To avoid issues in the future, </span><br><span class="line">you should not use TextEdit for editing it. </span><br><span class="line">If you are not using TextEdit, you should </span><br><span class="line">turn off smart quotes in your editor of choice.</span><br></pre></td></tr></table></figure></p><p>大致的意思是：在Podfile文件中，引号被智能的检测到并被忽略。</p><p>通过检查Podfile文件，发现了如下代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Demo’ do</span></span><br></pre></td></tr></table></figure><p>这明显是因为输入法切换导致的右引号写成了中文的单引号，这个问题很难被发现，即便没什么影响，但是改一下就可以消除警告，何乐为不为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;在执行&lt;code&gt;pod install&lt;/code&gt;命令时，出现了如下的警告：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>UIViewController继承时父子类方法重名造成的一个crash</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/31/UIViewController%E7%BB%A7%E6%89%BF%E6%97%B6%E7%88%B6%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%B8%AAcrash/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/</id>
    <published>2018-07-31T05:30:44.000Z</published>
    <updated>2018-08-02T12:29:26.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发过程中，遇到了一个因为UIViewController继承时父子类方法重名造成的一个crash问题，本文是问题的原因分析和解决方法。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="1-一个crash问题的分析"><a href="#1-一个crash问题的分析" class="headerlink" title="1.一个crash问题的分析"></a>1.一个crash问题的分析</h2><p>有如下父子类，<code>SubViewController</code>继承于<code>BaseViewController</code>，父子类中均有<code>-addConstraintsForSubviews</code>这个重名的私有方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">@implementation BaseViewController</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];    </span><br><span class="line">    //添加子视图</span><br><span class="line">    [self base_lazyLoadSubviews];</span><br><span class="line">    //添加约束</span><br><span class="line">    [self addConstraintsForSubviews];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//子类</span><br><span class="line">@implementation SubViewController</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];    </span><br><span class="line">    //添加子视图</span><br><span class="line">    [self sub_lazyLoadSubviews];</span><br><span class="line">    //添加约束</span><br><span class="line">    [self addConstraintsForSubviews];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>实际运行过程中，遇到了如下的crash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception </span><br><span class="line">&apos;NSInvalidArgumentException&apos;, reason: </span><br><span class="line">&apos;NSLayoutConstraint for &lt;UIImageView: </span><br><span class="line">0x10bee7fa0; frame = (0 0; 0 0); opaque = NO; </span><br><span class="line">userInteractionEnabled = NO; layer = &lt;CALayer: </span><br><span class="line">0x17023ba00&gt;&gt;: A multiplier of 0 or a nil </span><br><span class="line">second item together with a location for the </span><br><span class="line">first attribute creates an illegal constraint </span><br><span class="line">of a location equal to a constant. Location </span><br><span class="line">attributes must be specified in pairs.&apos;</span><br></pre></td></tr></table></figure><p>上述的<code>-addConstraintsForSubviews</code>方法中有用到AutoLayout做自动布局，crash也是因为自动布局导致的。<br>经过断点调试，也就是走了一遍ViewController的生命周期方法，分析出了这个crash的原因：</p><ul><li>1.子类执行<code>-viewDidLoad</code>时，调用了<code>[super viewDidLoad]</code>，触发父类的<code>-viewDidLoad</code>。</li><li>2.父类的<code>-viewDidLoad</code>方法中实现了基础的UI加载和布局，也就是父类对应的<code>-base_lazyLoadSubviews</code>和<code>-addConstraintsForSubviews</code>这两个方法。</li><li>3.当父类执行这两个方法时，其实就已经有问题了，因为子类有同名的<code>-addConstraintsForSubviews</code>方法，导致父类的方法实现被子类覆盖了，此时父类会去调用子类的<code>-addConstraintsForSubviews</code>去布局。</li><li>4.子类此时还没有执行<code>-sub_lazyLoadSubviews</code>方法，也就是子类的视图控件还没有添加到父视图上，此时执行AutoLayout，就造成了crash。</li></ul><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>在父类增加一些共有的UI组件，某些情况下可以简化开发，但其实更多的时候，并没有省却很多麻烦。个人建议还是不要在公有的父类中增加过多的UI特性，以免日后更多的不必要的麻烦，子类过多，已经足够引起你的重视了。当然如果只是项目中的基类，用作埋点或其他用途，那么增加其他的UI特性，更是不合适的了。<br>下面只是基于上述问题，提出对应的解决方案。</p><h3 id="2-1-规范命名"><a href="#2-1-规范命名" class="headerlink" title="2.1.规范命名"></a>2.1.规范命名</h3><p>这其实是算是一个命名不规范导致的问题，如果是父类私有的方法，还是增加前缀比较安全，所以最简单的解决方式就是改名：<br><code>-base_addConstraintsForSubviews</code><br><code>-sub_addConstraintsForSubviews</code></p><h3 id="2-2-更加优雅的解决方式"><a href="#2-2-更加优雅的解决方式" class="headerlink" title="2.2.更加优雅的解决方式"></a>2.2.更加优雅的解决方式</h3><p>上一种方法其实并不是很好，因为可能遇到其他开发者继承于你的父类的问题，如果每次都要告知对方去注意这些问题，就很容易出问题了。<br>这里提出一种参考系统的生命周期方法中回调父类的方式去解决这个问题。<br>在父类中的头文件，声明子类容易覆写的同类型方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface BaseViewController : UIViewController</span><br><span class="line">- (void)lazyLoadSubviews NS_REQUIRES_SUPER;</span><br><span class="line">- (void)addConstraintsForSubviews NS_REQUIRES_SUPER;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>方法声明过程中，使用了系统的宏<code>NS_REQUIRES_SUPER</code>来修饰，表示子类覆写该方法时，必须在方法内部调用super的这个方法，否则会有如下的警告（以系统的<code>UITableViewCell</code>的<code>-prepareForReuse</code>方法为例）：</p><p><img src="http://pcriprrao.bkt.clouddn.com/2018-08-01-UIViewController继承时父子类方法重名造成的一个crash-NS_REQUIRES_SUPE.png" alt="UIViewController继承时父子类方法重名造成的一个crash-NS_REQUIRES_SUPE"></p><p>这样即便子类使用者在不知情的情况下，覆写了父类的同名方法，也会有警告提示，只要执行了父类的同名方法，就可以避免上述的问题发生。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/shihuboke/article/details/78200339" target="_blank" rel="noopener">iOS 修饰符~ NS_UNAVAILABLE、NS_REQUIRES_SUPER</a></li><li><a href="https://www.dudas.co.uk/ns_requires_super/" target="_blank" rel="noopener">NS_REQUIRES_SUPER</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在开发过程中，遇到了一个因为UIViewController继承时父子类方法重名造成的一个crash问题，本文是问题的原因分析和解决方法
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="继承" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/30/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/30/Hexo-Github搭建个人博客/</id>
    <published>2018-07-30T06:59:56.000Z</published>
    <updated>2018-08-02T12:29:26.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍了在Mac环境下，通过Hexo+Github搭建个人博客的完整操作流程，笔者参考了部分现有的文章，通过实践，排除了一些坑，并多次尝试后，整理出本文。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h2><p>通过Homebrew安装，会很便捷，但是事后遇到了重启终端，执行<code>nvm</code>命令，报<code>-bash: npm: command not found</code>错误，只好重头做起，在<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>官网下载包安装，也很方便。<br><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">5分钟 搭建免费个人博客</a>一文中提到的，使用Homebrew安装Node.js的命令如下，请注意其中的注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install nvm</span><br><span class="line"><span class="meta">$</span> mkdir ~/.nvm</span><br><span class="line"><span class="meta">$</span> export NVM_DIR=~/.nvm</span><br><span class="line"><span class="meta">$</span> . $(brew --prefix nvm)/nvm.sh</span><br><span class="line"><span class="meta">$</span> nvm install 4 //这里是大坑，这个指定了安装的版本，截止到本文书写时，node的版本已经到8.x了</span><br></pre></td></tr></table></figure><p>个人建议还是直接去官网下载包安装。</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>这个是提交之后的内容必备的，Mac自带了git，就不再赘述。</p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>终端命令如下（Hexo官网上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时要在前面加上sudo，否则会因为权限问题报错）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="4-初始化Hexo"><a href="#4-初始化Hexo" class="headerlink" title="4.初始化Hexo"></a>4.初始化Hexo</h2><p>终端cd到自己选定的一个文件夹（之后所有的hexo相关的文件都将安装在文件夹中）的上一层级目录（选定的文件夹包含于该层级下），执行hexo init命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /Users/...</span><br><span class="line"><span class="meta">$</span> hexo init XXX //XXX是对应的自己建立的文件夹的名字，用于存放之后关于hexo的所有文件</span><br></pre></td></tr></table></figure><p>cd到XXX文件夹下，安装npm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd XXX</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure><h2 id="5-测试hexo"><a href="#5-测试hexo" class="headerlink" title="5.测试hexo"></a>5.测试hexo</h2><p>执行命令，开启hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo s</span><br></pre></td></tr></table></figure><p>执行命令后，在浏览器中访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><br>看到下面的页面，说明本地访问成功，hexo的初始化工作结束：</p><p><img src="http://pcriprrao.bkt.clouddn.com/2018-08-01-Hexo-Github搭建个人博客-测试hexo.jpg" alt="Hexo-Github搭建个人博客-测试hexo"></p><p>执行下面的命令可以停止测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> Ctrl+C</span><br></pre></td></tr></table></figure><h2 id="6-建立Github关联的仓库"><a href="#6-建立Github关联的仓库" class="headerlink" title="6.建立Github关联的仓库"></a>6.建立Github关联的仓库</h2><p>在github新建一个仓库，仓库名固定为<code>github用户名.github.io</code>。</p><p>例如笔者的就是：<a href="https://github.com/kukumaluCN/kukumaluCN.github.io">kukumaluCN.github.io</a></p><p>获取到仓库的地址和git地址，后面使用。</p><h2 id="7-配置-config-yml文件"><a href="#7-配置-config-yml文件" class="headerlink" title="7.配置_config.yml文件"></a>7.配置_config.yml文件</h2><p>在之前的XXX文件夹下，有<code>_config.yml</code>文件，该文件是hexo的配置信息，因为不同版本，该文件的信息会有变化，所以网上的很多教程都不太适用，需要自己综合参考修改，下面的是根据笔者当前的配置列出的示例。</p><p>需要修改的基本信息如下，如果有其他需要，可以参考官网<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo配置</a>自行修改（注意冒号后面必须有空格）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 霖溦之境 #Hexo 博客标题</span><br><span class="line">subtitle: 霖溦的个人博客 #博客副标题</span><br><span class="line">description: 霖溦的个人博客</span><br><span class="line">author: 霖溦 #作者名</span><br><span class="line">language: zh-Hans #中文</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://github.com/kukumaluCN/kukumaluCN.github.io #github仓库的地址</span><br><span class="line">root: /</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2 id="8-安装hexo-deployer-git自动部署发布工具"><a href="#8-安装hexo-deployer-git自动部署发布工具" class="headerlink" title="8.安装hexo-deployer-git自动部署发布工具"></a>8.安装hexo-deployer-git自动部署发布工具</h2><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="9-发布hexo"><a href="#9-发布hexo" class="headerlink" title="9.发布hexo"></a>9.发布hexo</h2><p>修改完上述配置后，可以再次hexo s执行一次测试，看看修改后的效果。没有问题就可以发布了。</p><p>在XXX文件夹下生成静态页面，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>这是三个命令，clean是清理缓存，g就是generate生成静态文件，d是deploy也就是最终的部署。</p><p>具体的命令参考官网：<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo指令</a></p><p>执行上述命令时，可能因为没有关联github提示输入github的用户名和密码（<strong>参考第10条，可能是deploy中repo的设置问题，改成ssh就不会遇到该提示了，前提是你的github绑定了ssh key</strong>）。</p><h2 id="10-发布文章"><a href="#10-发布文章" class="headerlink" title="10.发布文章"></a>10.发布文章</h2><p>cd到XXX目录下，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo new "title" //title是要发布的文章的标题</span><br></pre></td></tr></table></figure><p>title是要发布的文章的标题，具体规范参考<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo指令</a>中关于new的一项。</p><p>执行之后，会在/XXX/source/_posts路径下生成“title.md”文件，具体的书写就是标准的markdown语法了，可以自行使用习惯的md编辑器书写。</p><p>文章编辑完之后执行如下命令发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>期间遇到了如下错误：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for &apos;https://github.com/kukumaluCN/kukumaluCN.github.io.git/&apos;</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure><p>本以为是SSH key的问题，结果发现设置过了，经过实验，发现是配置文件的问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Deployment</span><br><span class="line"><span class="meta">#</span># Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line"><span class="meta">#</span>repo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址</span><br><span class="line">repo: git@github.com:kukumaluCN/kukumaluCN.github.io.git #改成ssh地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2 id="11-更换主题"><a href="#11-更换主题" class="headerlink" title="11.更换主题"></a>11.更换主题</h2><p>Hexo的主题有很多，具体参考：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Thems</a><br>这里以<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">maupassant</a>主题为例：<br>cd XXX到刚才的目录。<br>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line"><span class="meta">$</span> npm install hexo-renderer-pug --save</span><br><span class="line"><span class="meta">$</span> npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><p>再次修改配置文件_config.yml，将theme的值改为maupassant。<br>编辑完之后执行如下命令发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">5分钟 搭建免费个人博客</a></li><li><a href="https://www.jianshu.com/p/13e64c9e2295" target="_blank" rel="noopener">Mac上搭建基于GitHub的Hexo博客</a></li><li><a href="https://yegod.github.io/blog-1/" target="_blank" rel="noopener">如何搭建自己的博客</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/07/30/Hexo-Github搭建个人博客/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/07/30/Hexo-Github搭建个人博客/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要介绍了在Mac环境下，通过Hexo+Github搭建个人博客的完整操作流程，笔者参考了部分现有的文章，通过实践，排除了一些坑，并多次
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于霖溦之境</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/27/%E5%85%B3%E4%BA%8E%E9%9C%96%E6%BA%A6%E4%B9%8B%E5%A2%83/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/27/关于霖溦之境/</id>
    <published>2018-07-27T09:34:16.000Z</published>
    <updated>2018-08-02T12:29:26.433Z</updated>
    
    <content type="html"><![CDATA[<p>这里是霖溦的个人博客，从今天开始将在这里陆续更新博文，博文内容不限于iOS开发技术，也包含个人爱好的点滴。</p><p><strong>写于 2018.7.27</strong></p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/07/27/关于霖溦之境/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/07/27/关于霖溦之境/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是霖溦的个人博客，从今天开始将在这里陆续更新博文，博文内容不限于iOS开发技术，也包含个人爱好的点滴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写于 2018.7.27&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong
      
    
    </summary>
    
      <category term="随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="介绍" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E9%9A%8F%E7%AC%94/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="关于" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E5%85%B3%E4%BA%8E/"/>
    
  </entry>
  
</feed>
