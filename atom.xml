<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霖溦之境</title>
  
  <subtitle>霖溦的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/kukumaluCN/kukumaluCN.github.io/"/>
  <updated>2019-05-13T09:19:26.441Z</updated>
  <id>https://github.com/kukumaluCN/kukumaluCN.github.io/</id>
  
  <author>
    <name>霖溦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018书单</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/12/30/2018%E4%B9%A6%E5%8D%95/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/12/30/2018书单/</id>
    <published>2018-12-30T02:04:47.000Z</published>
    <updated>2019-05-13T09:19:26.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2018年，是不那么平凡的一年，发生了很多事，也经历了很多事。<br>按照APP的统计，今年一共读了30本书，在读书上一共累积了363小时，这是前两年数量的总和。像往年一样，大部分阅读时间，依旧是在上下班的地铁上。<br>大概是得益于阅读速度的提升，也可能是得益于今年年中，有那么一段不怎么加班的时光。想来，加班，真的是浪费生命的一件事吧，呵呵。<br>数量的增加，对应的质量，的确会相对的降低。<br>今年看了那么几本“烂书”……也是感慨，即便过程中觉察到了一本书不好，也总会想要坚持看完它，想知道那个故事的结局，想彻底了解它的缺陷。到底，不是书的问题，是作者的态度吧，如果作为读者也是这般虎头蛇尾，那个书中的世界，就彻底荒废了吧。</p><h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><h4 id="1-《时间的朋友2017》"><a href="#1-《时间的朋友2017》" class="headerlink" title="1.《时间的朋友2017》"></a>1.《时间的朋友2017》</h4><p>2018.1.2-2018.1.8<br>评价：★★★☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171257.png" alt=""></p><p>一直对于这类知识服务有一种特别的感触，像是速食食品，能吃饱，也很有味道，但就是总觉得怪怪的，可能是因为吸收太快，总不是那么的踏实。平时只是敢去听那些不想去读却又好奇的书籍，这类书籍的音频解读，真的只适合读后再去听，不然真的很破坏“美感”。<br>《时间的朋友2017》是《罗辑思维》他们家的跨年演讲系列之一，具有一定的时效性。之所以读这本书，也是出于好奇，某种程度上，它就像是安慰剂，给一些迷茫的人一盏灯，阅读体验很爽快，读后却又很空虚。也许，只是自己的修养还不够吧。</p><h4 id="2-《神们自己》"><a href="#2-《神们自己》" class="headerlink" title="2.《神们自己》"></a>2.<a href="https://book.douban.com/subject/26264967/" target="_blank" rel="noopener">《神们自己》</a></h4><p>2018.1.10-2018.1.27<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171314.png" alt=""><br>阿西莫夫的科幻小说，一本关于平行宇宙的幻想作品。<br>“面对愚昧，神们自己也缄口不言”，这是全书三部分的标题，也是核心。阿西莫夫用奇异的幻想视角，为读者展现了一种完全不同的外星文明和物种，他们来自一个拥有不同的物理法则的平行宇宙，感觉上，他们应该更加接近电磁生物。<br>“愚昧”，贯穿全书，归根到底，它源于利益和贪婪。面对愚昧，最好的选择，或许还是缄口不言。</p><h4 id="3-《奥菲利亚的影子剧院》"><a href="#3-《奥菲利亚的影子剧院》" class="headerlink" title="3.《奥菲利亚的影子剧院》"></a>3.<a href="https://book.douban.com/subject/2984402/" target="_blank" rel="noopener">《奥菲利亚的影子剧院》</a></h4><p>2018.1.27<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171326.png" alt=""><br>一本薄薄的绘本，一个温暖的故事。<br>说来有趣，大学时，写过一篇关于影子的短篇小说，当时找了很多关于影子的素材，其中一些，就源自这本绘本。<br>作者米切尔恩德，最有名的作品，应该还是《永远讲不完的故事》，当年大刘还推荐过。<br>每年都应该读一些童话，童话世界中的幻想，总是能出乎意料的精彩。</p><h4 id="4-《DK探索-太空旅行》"><a href="#4-《DK探索-太空旅行》" class="headerlink" title="4.《DK探索 太空旅行》"></a>4.《DK探索 太空旅行》</h4><p>2018.2.18<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171337.png" alt=""><br>过年期间带回去看的一本。DK系列都是那种大开本的科普书，很适合小孩子去培养兴趣。</p><h4 id="5-《黑客与画家》"><a href="#5-《黑客与画家》" class="headerlink" title="5.《黑客与画家》"></a>5.<a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与画家》</a></h4><p>2018.1.30-2018.3.10<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171349.png" alt=""><br>这是一本信息量很大的书，涉及了作者在很多方面的思考，比如编程思想，以及创业的一些思考。书如其名，作者将编程和绘画类比，进行阐述。书中的“黑客”不是我们通常意义上的黑客，而是其原本含义，更加接近我们通常所理解的“极客”。<br>书中阐述了作者关于优秀的软件设计的一些观点，读来很是受用。<br>关于自学，一直以来，最大的感受就是：“先做再学，需求推进”，不然永远是零，用书中的话就是：</p><blockquote><p>画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”这种情况对于第一线的程序员真是再熟悉不过了。</p></blockquote><h4 id="6-《东京一年》"><a href="#6-《东京一年》" class="headerlink" title="6.《东京一年》"></a>6.<a href="https://book.douban.com/subject/27074861/" target="_blank" rel="noopener">《东京一年》</a></h4><p>2018.3.18-2018.4.5<br>评价：★★★☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171402.png" alt=""><br>这是蒋方舟的一本日记形式的随笔集，记录了作者在东京独自生活一年的诸多感触。<br>中学时代就听过这个名字了，只是从未接触过她的作品。说实话刚开始没看清书名，看到封面的配色，还以为是关于“某东”的创业史……<br>内容不做过多的的评价，个人很喜欢读这类第一人称视角的随笔集，因为真切，所以很有代入感。能更加深切的感受到那个角色的那些经历。所谓的角色扮演，大概就是这样吧。<br>真的很羡慕，能有一年的时间，去日本这样的地方，独处，放空。</p><h4 id="7-《伏羲密码》"><a href="#7-《伏羲密码》" class="headerlink" title="7.《伏羲密码》"></a>7.<a href="https://book.douban.com/subject/27097477/" target="_blank" rel="noopener">《伏羲密码》</a></h4><p>2017.11.19-2018.4.15<br>评价：★☆☆☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171416.png" alt=""><br>一本因为名字和简介被骗进来的书……<br>本以为会是关于上古神话的幻想类小说，结果……<br>这是一本前言内容比正文更加精彩的书，讲述了作者的大学时光以及创业历程，以及偶然的机会出版这本大学时写的烂尾作的经历。<br>作者大概是想用一个科幻的视角，去阐述上古时代的伏羲神话，而且用了盗墓文学的展开。可惜全书挖坑不断，直到结尾也没有收住，彻底的坑了。前半部分的节奏还好，后面的就崩的不要不要的了，只能匆匆结尾。最关键的是，这本书今年还出了续作……</p><h4 id="8-《遗落的南境1：湮灭》"><a href="#8-《遗落的南境1：湮灭》" class="headerlink" title="8.《遗落的南境1：湮灭》"></a>8.<a href="https://book.douban.com/subject/26652880/" target="_blank" rel="noopener">《遗落的南境1：湮灭》</a></h4><p>2018.4.8-2018.4.21<br>评价：★★★☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171430.png" alt=""><br>这本是科幻电影《湮灭》的原著。电影给人最大的观感就是阴森诡谲，很多地方都看不大懂，结局更是令人细思极恐。其实原著更甚。<br>电影相对原著做了一定的改编，去掉了书中比较重要的几个设定。说实话个人不是很适应这类作品的观感，阅读体验很不舒适。<br>提到这部就不得不说其在星云奖的角逐中胜了《三体》。个人感觉，这两部作品没有太多可比性，不能算是同类型的作品，《三体》注重的的硬科幻设定，《湮灭》更多的是人性心理描写和气氛渲染，科幻内核较软。<br>个人比较喜欢大刘的幻想世界，他在架构一个世界时，会用一个很贴近我们身边现实的人物角色，带着我们一起，去探索和经历那个世界。而这部，相对来说各种环境都是陌生的，主角的内心世界亦是如此。一个幻想世界，没有引路人，读者冒然进入其中，会感到独孤，甚至是恐惧。或许在某种意义上，这也是一种优势吧。</p><h4 id="9-《半小时漫画中国史》"><a href="#9-《半小时漫画中国史》" class="headerlink" title="9.《半小时漫画中国史》"></a>9.<a href="https://book.douban.com/subject/27003014/" target="_blank" rel="noopener">《半小时漫画中国史》</a></h4><p>2018.4.28-2018.5.5<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171445.png" alt=""><br>一本浅显易懂的春秋战国史，作者以漫画的形式来展现那段历史的混乱，很生动，一些角色设定真的很形象。<br>这类入门读物，很适合初学者，或者是想理清历史脉络的人去读。就像作者在介绍中说的，只是想为大家提供一个历史框架，至于读者对哪段历史有了兴趣，想进一步研究，作者的目的其实已经达到了。</p><h4 id="10-《半小时漫画世界史》"><a href="#10-《半小时漫画世界史》" class="headerlink" title="10.《半小时漫画世界史》"></a>10.<a href="https://book.douban.com/subject/30191803/" target="_blank" rel="noopener">《半小时漫画世界史》</a></h4><p>2018.5.5-2018.5.11<br>评价：★★★☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171457.png" alt=""><br>作者一贯的极简风格，不过这本的内容比较宽泛零散。<br>书中涉及了世界史中的一些大事件。了解世界史还是有用的，至少在读外国文学作品时，了解对应的历史背景，更有助于理解其内涵，不然就只是流于故事表面了。</p><h4 id="11-《天意》"><a href="#11-《天意》" class="headerlink" title="11.《天意》"></a>11.<a href="https://book.douban.com/subject/27086744/" target="_blank" rel="noopener">《天意》</a></h4><p>2018.5.14-2018.5.23<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171516.png" alt=""><br>国产历史科幻小说，中国科幻“银河奖”获奖作品。<br>作者对于华夏文明的起源，开了一个巨大的脑洞，并用科幻的角度，在尊重史实的基础上，重构了楚汉之争那段历史。因为作者身为历史老师的缘故，书中对于历史人物的刻画，十分生动，而且女性的细腻笔触，在国内科幻作品中占有绝对优势。</p><h4 id="12-《那颗星星不在星图上：寻找太阳系的疆界》"><a href="#12-《那颗星星不在星图上：寻找太阳系的疆界》" class="headerlink" title="12.《那颗星星不在星图上：寻找太阳系的疆界》"></a>12.<a href="https://book.douban.com/subject/25775902/" target="_blank" rel="noopener">《那颗星星不在星图上：寻找太阳系的疆界》</a></h4><p>2018.5.23-2018.6.1<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171529.png" alt=""><br>一本关于太阳系各大行星探索和发现的科学史向的科普作品。<br>作者卢昌海先生，是一位十分有智有趣的人，他的科普作品，文如其人，科普能写出小说情节般的跌宕感。当然作者的科学素养是不容置疑的，也只有学识深厚的人，才能把科学史写的如此通俗生动。</p><h4 id="13-《我的“微言小义”》"><a href="#13-《我的“微言小义”》" class="headerlink" title="13.《我的“微言小义”》"></a>13.<a href="https://book.douban.com/subject/27081322/" target="_blank" rel="noopener">《我的“微言小义”》</a></h4><p>2018.6.1-2018.6.16<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171541.png" alt=""><br>这是科普作家卢昌海先生将个人微博中的精华部分整理成册，出版的一本随笔集。<br>书中涉及了作者对于生活、读书、观影、科普等诸多方面的思考和感想，足见作者的生活情趣。也因此，买了作者已经出版的所有书籍，以备阅读。</p><h4 id="14-《东野圭吾的最后致意》"><a href="#14-《东野圭吾的最后致意》" class="headerlink" title="14.《东野圭吾的最后致意》"></a>14.<a href="https://book.douban.com/subject/26390453/" target="_blank" rel="noopener">《东野圭吾的最后致意》</a></h4><p>2018.6.19-2018.7.1<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171552.png" alt=""><br>大概是养成了一个习惯，读某位作者的作品之前，必然要先了解下这个人，如果有自传，就必定要先读一下。<br>卢昌海先生在个人随笔集中表达了自己对于东野圭吾作品的喜爱之情。东野圭吾，其实并不陌生，各大出版物媒体平台的明星人物，然而一直都没看过他的书，这是第一本。<br>在这本自传中，东野圭吾自述为一个有趣却也无趣的人，他拥有和我们大多数人差不多的学生时代。工科出身的他，第一份工作和写作没有任何关系。他写作就是为了摆脱生活现状，说白了就是为了生存而写，当然兴趣也是前提。<br>通读全书，发现东野圭吾除了是一个目的性极强的人，也是一个极其自律的人，表现在它每天极为规律的作息，以及相对较高的产出。大概就是因为严苛，才能产出严谨的推理作品吧。</p><h4 id="15-《三体世界》"><a href="#15-《三体世界》" class="headerlink" title="15.《三体世界》"></a>15.<a href="https://book.douban.com/subject/26810947/" target="_blank" rel="noopener">《三体世界》</a></h4><p>2018.6.9-2018.7.1<br>评价：★★★☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171603.png" alt=""><br>这绝对是一本被低估了的书，一本被书名和出版方毁掉了的相对较好的国产科幻作品。大概是因为它出版那年，大刘的《三体》还没有那么大的影响力，《三体世界》无论从书名还是宣传标语，甚至是书中的某些科幻设定，都在一定程度上，蹭了《三体》的热度，《三体》大火之后，这本书毫无意外的，被打上了山寨的标签……<br>发现这本书完全是意外，大刘的《三体》在国际上获奖，在国内引起轰动之前，还只是科幻圈内的宠儿。那时在买书的时候，意外的发现了这本《三体世界》，本以为这是一本同人作，就像宝树的那本《三体X》一样，出于爱屋及乌的心态，一并买来留存。<br>那天出于好奇，翻开来读，情节居然意外的吸引人。在豆瓣上看了下评价，大都的是针对其山寨行径的无情差评。摒弃这些，耐下心看完这本书之后，还是有些感慨的。<br>这本书的科幻内核还是比较硬的，作者在太阳系维度，构建了一个三体世界，三星系统中包括太阳、太阳伴星<a href="https://baike.baidu.com/item/复仇女神星" target="_blank" rel="noopener">复仇女神星</a>（这个概念不是作者原创的）、以及一个类似人造虫洞的天体。作者通篇运用了大量的量子力学和弦理论的作为故事情节的主要设定。<br>本书在人设上，有网络文学的痕迹，比较严重的后宫倾向主角团。悬疑设定过于简单粗暴，但是好在足够吸引人。对于量子力学和弦论的引用比较生硬，基本是大段的科普，没有较为生动的转述，阅读门槛较高。全书至关重要的“希望之桥”的设定，和《三体》中的二向箔类似，原理都是<a href="https://baike.baidu.com/item/真空衰变" target="_blank" rel="noopener">真空衰变</a>，只是在情节中的作用不同，不能算是撞梗。这本书的结局是出人意料的，构造了一个死亡循环的死局，比较出彩。<br>如果这本书作为同人作的话，部分情节稍微润色下，绝对是优秀作品了，至少在国内科幻，算是中上水平的。有时候，出版社的决策，直接决定了一本书的生死。</p><h4 id="16-《果壳里的一百五十九个宇宙》"><a href="#16-《果壳里的一百五十九个宇宙》" class="headerlink" title="16.《果壳里的一百五十九个宇宙》"></a>16.<a href="https://book.douban.com/subject/26921237/" target="_blank" rel="noopener">《果壳里的一百五十九个宇宙》</a></h4><p>2018.7.1-2018.7.15<br>评价：★★☆☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171618.png" alt=""><br>网红科学家李淼先生的科幻脑洞随笔集，全书由159个短篇脑洞随笔组成。其中有几篇写的很有意思，但是大部分的都较为平庸。想看科学家如何做科幻设定，那些优秀篇目还是很有参考价值的。</p><h4 id="17-《我的晃荡的青春》"><a href="#17-《我的晃荡的青春》" class="headerlink" title="17.《我的晃荡的青春》"></a>17.<a href="https://book.douban.com/subject/26576518/" target="_blank" rel="noopener">《我的晃荡的青春》</a></h4><p>2018.7.15-2018.7.23<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171630.png" alt=""><br>东野圭吾的青春回忆录，这本是其在《东野圭吾的最后致意》中反复被提及的作品。<br>通篇讲述了作者学生时代作为“学渣”的各种有趣的经历，很有意思。<br>一个人的经历，在其日后的作品中，多多少少的都会有着那些身影吧。</p><h4 id="18-《借东西的小人》"><a href="#18-《借东西的小人》" class="headerlink" title="18.《借东西的小人》"></a>18.<a href="https://book.douban.com/subject/26830987/" target="_blank" rel="noopener">《借东西的小人》</a></h4><p>2018.7.23-2018.7.27<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171644.png" alt=""><br>吉卜力同名动画的原著，一直都还没有看过这部动画，恰好看到了这本书。<br>作为童话故事，这本书讽刺了很多现实。<br>小孩子总是能看到一些我们看不到的有趣事物吧？想来也是可悲，虽然我们年龄增长了，认知能力提升了，却越来越不能接受那些超出我们所谓常识常理的事物了。那被我们视为珍宝的想象力，有的时候，却也因某些莫名的恐惧而被我们抗拒着。<br>人大抵是趋于安稳的吧，这种趋势源于我们的惰性，这种平衡不允许被任何意外打破，即便那曾是我们向往的、期待的，不平凡。</p><h4 id="19-《与罗摩相会》"><a href="#19-《与罗摩相会》" class="headerlink" title="19.《与罗摩相会》"></a>19.<a href="https://book.douban.com/subject/30161861/" target="_blank" rel="noopener">《与罗摩相会》</a></h4><p>2018.7.26-2018.8.7<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171656.png" alt=""><br>一部令人敬畏的科幻神作！<br>这本书早年被翻译为《与拉玛相会》。<br>大刘很喜欢阿瑟克拉克的作品，曾谦逊的表示自己的作品是对其拙劣的模仿。看过阿瑟克拉克的作品就会了解到一些原因，阿瑟克拉克的作品充斥着严谨的硬科幻设定，以及大量的技术细节。大刘的作品也有类似的特质。<br>这本书讲述了人类探索一艘意外闯入太阳系的外星飞船的过程。直至全书结束，也没有出现过外星人，最后外星飞船“意外”的飞离太阳系，人类由恐慌变成了失望，一种因被外星超级文明的忽视的恼怒和失望。在超级文明面前，人类并不值得被接触。<br>探索“罗摩”的过程，很像是一次针对失落的文明的古墓探险，或是神庙朝圣，面对未知的神迹，人类试图的探索，总会和宗教朝圣相类似。<br>或许留白，才是对外星文明最准确的描述，因为那种文明绝对超乎我们一切的想象力所能及。</p><h4 id="20-《山茶文具店》"><a href="#20-《山茶文具店》" class="headerlink" title="20.《山茶文具店》"></a>20.<a href="https://book.douban.com/subject/28656614/" target="_blank" rel="noopener">《山茶文具店》</a></h4><p>2018.8.7-2018.8.20<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171708.png" alt=""><br>年度暖心之作！<br>日本镰仓真的是一个令人向往的地方啊。<br>书中的主角内心戏丰富，很有意思，她总能以一个有趣的视角看待人和事，给各种人根据其特点起外号。她身边的人也都很有意思。然而她的童年却并不美好。人生总会充满了缺憾，有时，只是因为我们不会去爱吧。<br>代笔人，是怎样的一种体验呢？<br>鳗鱼饭，真的很好吃吧。</p><h4 id="21-《十二个明天》"><a href="#21-《十二个明天》" class="headerlink" title="21.《十二个明天》"></a>21.<a href="https://book.douban.com/subject/30271625/" target="_blank" rel="noopener">《十二个明天》</a></h4><p>2018.8.25-2018.10.11<br>评价：★★☆☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171722.png" alt=""><br>一部作者阵容豪华的短篇小说集，开篇就是大刘的新作《黄金原野》。<br>然而，不知道是不是翻译的问题，除了包括《黄金原野》在内的几篇作品，其他的，可读性都很差。<br>耐着性子读下去的，不过还是有一篇实在看不下去，因为没看懂……</p><h4 id="22-《韭菜的自我修养》"><a href="#22-《韭菜的自我修养》" class="headerlink" title="22.《韭菜的自我修养》"></a>22.<a href="https://book.douban.com/subject/30314653/" target="_blank" rel="noopener">《韭菜的自我修养》</a></h4><p>2018.9.21-2018.10.12<br>评价：★★★☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171735.png" alt=""><br>李笑来的一本小册子，关于这本书出版的目的不做任何评论。单从理财角度看，对于新手来说，应该还是有一些借鉴意义的。</p><h4 id="23-《给忙碌者的天体物理学》"><a href="#23-《给忙碌者的天体物理学》" class="headerlink" title="23.《给忙碌者的天体物理学》"></a>23.<a href="https://book.douban.com/subject/30246268/" target="_blank" rel="noopener">《给忙碌者的天体物理学》</a></h4><p>2018.7.2-2018.11.15<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171746.png" alt=""><br>一本关于当代天体物理学前言理论的简介的科普读物。一本装帧横精美的小册子，很方便随身携带翻阅。<br>断断续续的看了一阵子，后来又重头开始一口气看完了，内容很精彩。对于想要了解当代天体物理学所描述的宇宙简史的人，是一本不错的入门读物。<br>内容形式上很像《七堂极简物理课》。</p><h4 id="24-《猎户座防线》"><a href="#24-《猎户座防线》" class="headerlink" title="24.《猎户座防线》"></a>24.<a href="https://book.douban.com/subject/6739923/" target="_blank" rel="noopener">《猎户座防线》</a></h4><p>2018.11.12-2018.11.15<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171757.png" alt=""><br>《Xeelee》中的一部短篇科幻作品。硬科幻的典型代表之作。因为国内并没有引进，网上只能看到《猎户座防线》这部分的翻译内容。<br>改变物理常数，会发生什么？以物理法则为武器，如何发动战争？相对于直接使用物理法则作为武器的光粒或者二向箔，改变物理法则，真的更可怕。</p><h4 id="25-《古蜀》"><a href="#25-《古蜀》" class="headerlink" title="25.《古蜀》"></a>25.<a href="https://book.douban.com/subject/26747354/" target="_blank" rel="noopener">《古蜀》</a></h4><p>2018.11.4-2018.11.20<br>评价：★★☆☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171810.png" alt=""><br>王晋康老师的一本神话幻想小说。<br>作为中国科幻四天王之一，王晋康老师的作品，我还是第一次接触。<br>偶然看到了这本书，因为对神话题材很感兴趣，又因为涉及了古蜀国文明，就很有开心的入坑了……<br>作为一位科幻作家，在这本书中，作者的表述方式总给人一种掉书袋的感觉，各种生僻字生僻词汇。而且神话幻想方面也很俗套，毫无惊艳之处。<br>本书作为一本面向青少年的幻想类作品，其实内容并不是那么的合格。很多性暗示的情节，处理的很不恰当，即便上古先民对这些还没有过多的礼仪限制，但是浪漫的手法总应该是要有的。</p><h4 id="26-《程序员的爱情》"><a href="#26-《程序员的爱情》" class="headerlink" title="26.《程序员的爱情》"></a>26.<a href="https://book.douban.com/subject/4196673/" target="_blank" rel="noopener">《程序员的爱情》</a></h4><p>2018.5.5-2018.11.23<br>评价：★☆☆☆☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171822.png" alt=""><br>一本让我很无语的书……<br>本来是特意找来做为参考的，可惜这本书简直就是灾难……<br>可以看得出，作者应该是程序员出身，因为一些工作场景的描述的确很程序员，没有经历过的人，大概很难描绘，个人作为程序员，还是深有感触的。但是在爱情描写方面，不是作者笔力不够，就是作者的爱情观有问题。<br>这部作品的感情线，就是集车祸、出轨、包养、特殊身世等一堆烂梗于一身的无聊透顶的堆叠。看完这本书，大概很多人不会再相信爱情了吧……<br>作者在故事情节整体的把控能力上表现的很差，中段的情节有明显的拼凑堆叠的嫌疑，很多描写也不明所以，后期节奏加快，也就是最灾难的部分，各种意外，各种反转……最奇葩的，就是结局采用了留白的方式，不知道是不是作者已经无力结束这一切，总之书中那可怜的男主，渣的境界得到了终极升华……<br>几度弃书，终是耐着足够的性子读完了，大概是想引以为戒吧。</p><h4 id="27-《写给大人的睡前故事》"><a href="#27-《写给大人的睡前故事》" class="headerlink" title="27.《写给大人的睡前故事》"></a>27.<a href="https://book.douban.com/subject/30360935/" target="_blank" rel="noopener">《写给大人的睡前故事》</a></h4><p>2018.5.5-2018.11.23<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171833.png" alt=""><br>一本很有意思的短篇小说集，其中有几篇的构思还是很精巧的。睡前读的确会很适合，可惜我是早上读的。</p><h4 id="28-《龙猫的肚子为什么软绵绵》"><a href="#28-《龙猫的肚子为什么软绵绵》" class="headerlink" title="28.《龙猫的肚子为什么软绵绵》"></a>28.<a href="https://book.douban.com/subject/30162926/" target="_blank" rel="noopener">《龙猫的肚子为什么软绵绵》</a></h4><p>2018.4.23-2018.12.21<br>评价：★★★★☆<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171849.png" alt=""><br>每年都想读一本关于宫崎骏或者吉卜力的作品，因为实在有很多东西值得发掘和思考。<br>这是一本信息量比较大的书籍，作者在吉卜力师从铃木敏夫，收获了很多很有意思的关于创作的见解。从某种意义上来讲，铃木敏夫成就了宫崎骏。<br>想来，吉卜力的电影之所以耐看，还真的是因为信息量大的问题，真人电影的信息量看似更大，但是动画是以抽象化的角度重构的信息，更加容易令人接受，这样有效的信息量就会相对高很多，吉卜力的动画的特色和制作技法，在诸多动画作品中，无疑具有更大的信息量。</p><h4 id="29-《看见》"><a href="#29-《看见》" class="headerlink" title="29.《看见》"></a>29.<a href="https://book.douban.com/subject/20427187/" target="_blank" rel="noopener">《看见》</a></h4><p>2017.2.12-2018.12.23<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171900.png" alt=""><br>其实这本书的阅读跨度长达两年之久，之所以会这样，是因为这本书每个章节的篇幅很长，信息量也很大，不是很喜欢用碎片化的时间去读这类作品，只能等到没什么事的周末，找一个下午或者一整天来读。<br>柴静的文字就像她的性格，简洁、锋利，单刀直入，无所顾忌，直戳人心。我不会更多的去评价她这个人，也无法直接评价这本书。这本书所记录的，是这个时代的一些缩影，并不能读一遍就消化的掉，而且因为个人阅历的限制，很多东西，还不能深刻的去理解。<br>以后找时间，还是要再读一遍才好。</p><h4 id="30-《催眠师手记2》"><a href="#30-《催眠师手记2》" class="headerlink" title="30.《催眠师手记2》"></a>30.<a href="https://book.douban.com/subject/30179767/" target="_blank" rel="noopener">《催眠师手记2》</a></h4><p>2018.4.24-2018.12.29<br>评价：★★★★★<br><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171910.png" alt=""><br>个人很喜欢高铭的作品，有脑洞，也有思考。大学时代看完了这本书的第一季，第二季一出来，第一时间就买来看了。<br>这一季的故事还是很精彩的，很贴近当下的现实。很多时候，梦境，真的反映了太多的东西，只是我们没有觉察到，或是觉察到了没有明白。在这个社会中，我们多多少少都会有一些心理上的问题，如果能有机会接受一些科学的心理治疗或是调节，可能会更加利于身心健康吧。<br>所以，《时间线》系列是要出单行本吗？</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上，就是今年的修行了，明年继续~<br>今年还在得到APP和喜马拉雅APP上听了75本书，只能算是囫囵的了解了一些大概的点，想要有所得，大概还是要细细去读才好。</p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/12/30/2018书单/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/12/30/2018书单/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2018年，是不那么平凡的一年，发生了很多事，也经历了很多事。&lt;br&gt;按照APP的统计，今年一共读了30本书，在读书上一共累积了363小时，
      
    
    </summary>
    
      <category term="总结" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2018" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%80%BB%E7%BB%93/2018/"/>
    
    
      <category term="总结" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="书单" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>关于转场动画中“Unbalanced calls to begin/end appearance transitions for \&lt;UIViewController\&gt;”警告的解决</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/12/05/%E5%85%B3%E4%BA%8E%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E4%B8%AD%E2%80%9CUnbalanced-calls-to-begin-end-appearance-transitions-for-UIViewController-%E2%80%9D%E8%AD%A6%E5%91%8A%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/12/05/关于转场动画中“Unbalanced-calls-to-begin-end-appearance-transitions-for-UIViewController-”警告的解决/</id>
    <published>2018-12-05T01:56:07.000Z</published>
    <updated>2019-05-12T08:57:13.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>最近学习转场动画时，参考了喵神的这篇文章：<a href="https://onevcat.com/2013/10/vc-transition-in-ios7/" target="_blank" rel="noopener">WWDC 2013 Session笔记 - iOS7中的ViewController切换</a>，文中有这样一段示例代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContainerVC.m</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> addChildViewController:toVC];</span><br><span class="line">[fromVC willMoveToParentViewController:<span class="literal">nil</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:toVC.view];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span> transitionFromViewController:fromVC</span><br><span class="line">                  toViewController:toVC duration:<span class="number">0.3</span></span><br><span class="line">                           options:<span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span></span><br><span class="line">                        animations:^&#123;&#125;</span><br><span class="line">                        completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">    [fromVC.view removeFromSuperView];</span><br><span class="line">    [fromVC removeFromParentViewController];</span><br><span class="line">    [toVC didMoveToParentViewController:weakSelf];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>是iOS7以前的转场动画的实现方案，实验这段代码时，控制台报了如下警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unbalanced calls to begin/end appearance transitions for &lt;UIViewController: 0x7fc28fc1c080&gt;.</span><br></pre></td></tr></table></figure><p>通过查找原因，解决方案如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContainerVC.m</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> addChildViewController:toVC];</span><br><span class="line">[fromVC willMoveToParentViewController:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span> transitionFromViewController:fromVC</span><br><span class="line">                  toViewController:toVC duration:<span class="number">0.3</span></span><br><span class="line">                           options:<span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span></span><br><span class="line">                        animations:^&#123;&#125;</span><br><span class="line">                        completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">    [fromVC removeFromParentViewController];</span><br><span class="line">    [toVC didMoveToParentViewController:weakSelf];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>只是去掉了关于<code>vc.view</code>的操作，解释在这里：<br><a href="https://stackoverflow.com/questions/22676938/unbalanced-calls-to-begin-end-appearance-transitions-for-uiviewcontroller" target="_blank" rel="noopener">Unbalanced calls to begin/end appearance transitions for \&lt;UIViewController></a></p><blockquote><p>Turns out transitionFromViewController:toViewController:duration:options:animations:completion: <strong>also adds the view.</strong></p><p>This method adds the second view controller’s view to the view hierarchy and then performs the animations defined in your animations block. After the animation completes, it removes the first view controller’s view from the view hierarchy.<br>Which means the addSubview needs to be adjusted accordingly.</p></blockquote><p>也就是说<code>transitionFromViewController:toViewController:duration:options:animations:completion:</code>这个方法内部已经做了关于<code>vc.view</code>的管理，我们不需要再自行添加和移除对应的view了。</p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/12/05/关于转场动画中“Unbalanced-calls-to-begin-end-appearance-transitions-for-UIViewController-”警告的解决/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/12/05/关于转场动画中“Unbalanced-calls-to-begin-end-appearance-transitions-for-UIViewController-”警告的解决/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;最近学习转场动画时，参考了喵神的这篇文章：&lt;a href=&quot;https://onevcat.com/2013/10/vc-t
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="转场动画" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>一种字符串关键字检索高亮的简易实现</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/11/22/%E4%B8%80%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%B3%E9%94%AE%E5%AD%97%E6%A3%80%E7%B4%A2%E9%AB%98%E4%BA%AE%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/11/22/一种字符串关键字检索高亮的简易实现/</id>
    <published>2018-11-22T08:07:54.000Z</published>
    <updated>2019-05-13T09:12:55.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文Demo地址：<strong><a href="https://github.com/kukumaluCN/JXT_iOS_Demos/tree/master/JXTKit">Demo</a></strong>，喜欢请star<br>我的Demo集合：<strong><a href="https://github.com/kukumaluCN/JXT_iOS_Demos">JXT_iOS_Demos</a></strong>，喜欢请star</p></blockquote><p>平时开发中，我们总会不时的和富文本打交道。有时，我们需要用富文本高亮某句话中的某个关键字，如果这个关键字只出现一次，或者说这句话比较短，用<code>- (NSRange)rangeOfString:(NSString *)searchString</code>这个方法就可以很容易的确定这些关键字的<code>range</code>，如果是固定的一句话，那甚至可以将<code>range</code>写成固定值。但是如果是一篇文章，就会相对棘手些。<br>这个问题其实很像是关键字检索高亮的问题，网上有很多相关的算法甚至三方库，比如<strong><a href="https://github.com/IvanoBilenchi/ICTextView">ICTextView</a></strong>，下面提供一个十分简单的基于系统API的方法来解决这个问题，效果如下：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513171215.gif" alt=""></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>其实这个算法的核心就在于如何同时获取到字符串中重复出现的所有的子串的<code>range</code>，<code>- (NSRange)rangeOfString:(NSString *)searchString</code>方法只能获取到第一次出现的子串的<code>range</code>，设置<code>NSStringCompareOptions</code>，可以改变获取到的结果，但是也只能获取到一个，不知道系统有没有提供直接的方法，笔者暂时是没有发现……<br>简单的算法就是遍历，网上也有很多人提供了代码，但大部分都是多次遍历，效率肯定不会太好，经过调试和优化，笔者有了如下方法，通过几万字的字符串匹配验证，依旧可以保持在毫秒级，应该是可以适用于大部分简单的场景了，主要是算法相对于正则或者其他方式，简单易懂：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jxt_enumerateRangeOfString:(<span class="built_in">NSString</span> *)searchString usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSRange</span> searchStringRange, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] &amp;&amp; <span class="keyword">self</span>.length &amp;&amp;</span><br><span class="line">        [searchString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] &amp;&amp; searchString.length) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*separatedArray = [<span class="keyword">self</span> componentsSeparatedByString:searchString];</span><br><span class="line">        <span class="keyword">if</span> (separatedArray.count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSUInteger</span> count = separatedArray.count - <span class="number">1</span>; <span class="comment">//少遍历一次，因为拆分之后，最后一部分是没用的</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> length = searchString.length;</span><br><span class="line">        __block <span class="built_in">NSUInteger</span> location = <span class="number">0</span>;</span><br><span class="line">        [separatedArray enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> * _Nonnull componentString, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == count) &#123;</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                location += componentString.length; <span class="comment">//跳过待筛选串前面的串长度</span></span><br><span class="line">                <span class="keyword">if</span> (block) &#123;</span><br><span class="line">                    block(<span class="built_in">NSMakeRange</span>(location, length), idx, stop);</span><br><span class="line">                &#125;</span><br><span class="line">                location += length; <span class="comment">//跳过待筛选串的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[attributedString.string jxt_enumerateRangeOfString:searchString usingBlock:^(<span class="built_in">NSRange</span> searchStringRange, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    [attributedString addAttributes:@&#123;</span><br><span class="line">                                      <span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> redColor],</span><br><span class="line">                                      <span class="built_in">NSBackgroundColorAttributeName</span>:[[<span class="built_in">UIColor</span> blueColor] colorWithAlphaComponent:<span class="number">0.2</span>],</span><br><span class="line">                                      &#125; range:searchStringRange];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>本文作者：</strong> 霖溦<br><strong>本文链接：</strong> <a href="https://kukumalucn.github.io/blog/2018/11/22/一种字符串关键字检索高亮的简易实现/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/11/22/一种字符串关键字检索高亮的简易实现/</a><br><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文Demo地址：&lt;strong&gt;&lt;a href=&quot;https://github.com/kukumaluCN/J
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="NSString" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/NSString/"/>
    
      <category term="关键字" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="检索" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于performSelector的一点注意</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/11/16/%E5%85%B3%E4%BA%8EperformSelector%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/11/16/关于performSelector的一点注意/</id>
    <published>2018-11-16T08:15:02.000Z</published>
    <updated>2019-05-13T09:08:18.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刚在群里看到这样一段代码，很有意思：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的执行结果会是什么呢？<br>是打印“1、2”，还是“1、3、2”，或者是“1、2、3”？</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="1-问题探究"><a href="#1-问题探究" class="headerlink" title="1.问题探究"></a>1.问题探究</h2><p>这其实是一道很有意思的面试题，内容涉及runloop这个知识点。<br><strong>答案是只打印：“1、2”。</strong><br>原因群里的大神给了解答：</p><blockquote><p>因为<code>[self performSelector:@selector(test) withObject:nil afterDelay:.0]</code>实际在runloop里面，是一个定时器，但是因为在子线程，runloop是默认没有开启的。</p></blockquote><p>这除了涉及runloop，还有多线程的问题，有兴趣的可以深究。<br>其实我们只要仔细阅读苹果API的注释，就能解释这个问题：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170430.png" alt="performSelectorafterDelay"></p><p>想要执行<code>-test</code>方法，注释里也提供了解决办法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>其实针对上述的逻辑，更简单的是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h2 id="2-引发的思考"><a href="#2-引发的思考" class="headerlink" title="2.引发的思考"></a>2.引发的思考</h2><h3 id="2-1-不要懒"><a href="#2-1-不要懒" class="headerlink" title="2.1.不要懒"></a>2.1.不要懒</h3><p>之所以要提上述的问题，除了这个面试的“考点”，其实在平时的开发过程中也要注意自己代码的严谨性。<br>我发现自己在阅读别人的代码时，就见过同样的写法，其实甚至那些比较有名的三方库，例如“<code>YYText</code>”中，也有类似的代码存在：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>写这段代码的人只是为了通过selector来立刻执行某一方法，<code>delay</code>并不是他们的需求，为什么还要“多此一举”呢？<br>这里一大部分原因，很可能还是因为我们被xcode的自动提示给“惯坏了”：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170500.png" alt="perform自动提示"></p><p>毕竟当你写代码时，罗列的一堆提示，只是按照API相似度排列出来的，很多人看到了自己需要的就直接回车了，不需要<code>delay</code>，直接写0，就行了，反正“都一样”……<br>其实这是一个误区，看起来很相似的API，实则并不一样，而且很不一样：</p><ul><li>我们常用的这个perform，是<code>NSObject.h</code>这个头文件下的方法：</li></ul><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170532.png" alt="perform不一样1"></p><ul><li>可以delay的，是<code>NSRunLoop.h</code>下的方法：</li></ul><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170554.png" alt="perform不一样2"></p><ul><li>而之前提到的回调主线程的，是<code>NSThread.h</code>里的方法：</li></ul><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170628.png" alt="perform不一样3"></p><p>虽然他们都是NSObject的方法或者是分类补充方法，但实际上，是隶属于不同的模块的。</p><h3 id="2-2-更深刻的原因"><a href="#2-2-更深刻的原因" class="headerlink" title="2.2.更深刻的原因"></a>2.2.更深刻的原因</h3><p>但是“<code>YYText</code>”的作者应该是不会犯这种低级错误的，那就应该还有更深刻的原因了：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170654.png" alt="PerformSelectormacausealeak"></p><p>我们很多人应该总是会被上述的警告所困扰，大多数人的解决方式，就是利用类似相面的方式去屏蔽警告，这种做法虽然简单，但实际是有风险的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line"><span class="comment">//code</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>其实除了利用<code>IMP</code>或者<code>NSInvocation</code>那种比较“高端”的方式，更多的情况下，在方法没有返回值时，或者我们不需要返回值时，我们可以用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>这种方式去避免警告的，看上面的那三个对比你就会发现，后两类API，同样是<code>performSelector</code>，却没有返回值，这其实也是有官方注释的依据的：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170715.png" alt="PerformSelector官方注释2"></p><p>但其实你也要注意到了，官方的建议还是很严谨的，是用<code>performSelectorOnMainThread</code>，而不是delay0的方式，至于原因，我们又回到了文章一开头的讨论了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面看似无意义的探究，我们还是可以得到很深刻的教训的：“苹果霸霸”还是很严谨的，多看API的注释，总是没错的。</p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/11/16/关于performSelector的一点注意/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/11/16/关于performSelector的一点注意/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;刚在群里看到这样一段代码，很有意思：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="performSelector" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/performSelector/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods的版本升级和降级</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/09/20/Cocoapods%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/09/20/Cocoapods的版本升级和降级/</id>
    <published>2018-09-20T08:17:33.000Z</published>
    <updated>2019-05-12T08:57:13.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>在平时开发中，有时可能会遇到Cocoapods的版本的问题，我们实际使用的版本可能会因为过低而导致各种问题，这时需要升级，有时又会因为某个开源库不支持最新的Cocoapods版本而不得不降级我们本地的Cocoapods。</p><ul><li>1.升级</li></ul><p>升级比较简单，实际命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo gem install -n /usr/local/bin cocoapods -v 1.5.3</span><br></pre></td></tr></table></figure><p><code>-v</code>后面是版本号，当前Cocoapods的release版为1.5.3。<br>输入密码之后即可执行升级操作。<br>升级结束后，可以查看下当前的pod版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//执行命令查看版本信息</span><br><span class="line"><span class="meta">$</span> pod --version</span><br><span class="line">//输出的版本号是最新的</span><br><span class="line">1.5.3</span><br></pre></td></tr></table></figure><ul><li>2.切换Ruby源</li></ul><p>执行上述命令时，可能会遇到如下的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  Could not find a valid gem 'cocoapods' (= 1.5.3), here is why:</span><br><span class="line">          Unable to download data from https://gems.ruby-china.org/ - bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz)</span><br></pre></td></tr></table></figure><p>这是因为之前在配置Cocoapods时，本地的源设置的问题，这篇文章写下时，RubyGems的国内镜像已经变成了：<code>https://gems.ruby-china.com</code>。<br>我们需要手动切换一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查询本地源的列表</span><br><span class="line"><span class="meta">$</span> gem sources -l</span><br><span class="line">//删除已经不能使用的源</span><br><span class="line"><span class="meta">$</span> gem sources --remove https://gems.ruby-china.org/</span><br><span class="line">//添加最新的源</span><br><span class="line"><span class="meta">$</span> gem sources -a https://gems.ruby-china.com</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//再次查询</span><br><span class="line"><span class="meta">$</span> gem sources -l</span><br><span class="line"></span><br><span class="line">//可以看下如下信息，表示切换成功：</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://gems.ruby-china.com</span><br></pre></td></tr></table></figure><ul><li>3.降级</li></ul><p>和执行升级操作一样，比如想要安装1.5.0版本，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo gem install -n /usr/local/bin cocoapods -v 1.5.0</span><br></pre></td></tr></table></figure><p>提示安装成功后，再次查询版本号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//执行命令查看版本信息</span><br><span class="line"><span class="meta">$</span> pod --version</span><br><span class="line">//输出的版本号依旧是最新的</span><br><span class="line">1.5.3</span><br></pre></td></tr></table></figure><p>这是因为本地安装了多个版本的cocoapods，默认使用最新的版本，想要切换低版本，可以执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//执行卸载命令</span><br><span class="line"><span class="meta">$</span> sudo gem uninstall cocoapods</span><br><span class="line"></span><br><span class="line">//提示卸载哪一版本，并列出本地安装过的所有版本</span><br><span class="line">Select gem to uninstall:</span><br><span class="line"> 1. cocoapods-1.1.1</span><br><span class="line"> 2. cocoapods-1.2.1</span><br><span class="line"> 3. cocoapods-1.3.1</span><br><span class="line"> 4. cocoapods-1.5.0</span><br><span class="line"> 5. cocoapods-1.5.3</span><br><span class="line"> 6. All versions</span><br><span class="line"></span><br><span class="line">//输入5，卸载最新的那一版本</span><br><span class="line"><span class="meta">&gt;</span> 5</span><br><span class="line"></span><br><span class="line">//提示卸载成功</span><br><span class="line">Successfully uninstalled cocoapods-1.5.3</span><br><span class="line"></span><br><span class="line">//查询版本号，可以看到此时使用的是1.5.0，也就是当前最新的版本了</span><br><span class="line"><span class="meta">$</span> pod --version</span><br><span class="line">1.5.0</span><br></pre></td></tr></table></figure><p>除了上述的方法，还可以:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//列出所有信息</span><br><span class="line"><span class="meta">$</span> gem list</span><br><span class="line"></span><br><span class="line">//找到此项</span><br><span class="line">cocoapods (1.1.1, 1.2.1, 1.3.1, 1.5.0, 1.5.3)</span><br><span class="line"></span><br><span class="line">//移除指定版本cocoapods</span><br><span class="line"><span class="meta">$</span> sudo gem uninstall cocoapods -v 1.5.3</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://segmentfault.com/q/1010000004207378/a-1020000004207497" target="_blank" rel="noopener">安装CocoaPods 出现这样的问题</a></li><li><a href="https://blog.csdn.net/hsf_study/article/details/69945473" target="_blank" rel="noopener">升级 Cocoapods 到1.2.0指定版本，降低版本及卸载</a></li><li><a href="https://blog.csdn.net/focusjava/article/details/51325802" target="_blank" rel="noopener">iOS开发中如何管理多个版本的Cocoapods、gem</a></li><li><a href="https://www.cnblogs.com/ningmengcao-ios/p/5882505.html" target="_blank" rel="noopener">cocoapods 卸载,重装,高版本的使用</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/09/20/Cocoapods的版本升级和降级/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/09/20/Cocoapods的版本升级和降级/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;在平时开发中，有时可能会遇到Cocoapods的版本的问题，我们实际使用的版本可能会因为过低而导致各种问题，这时需要升级，有
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>随机内容字符串</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/13/%E9%9A%8F%E6%9C%BA%E5%86%85%E5%AE%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/13/随机内容字符串/</id>
    <published>2018-08-13T05:51:43.000Z</published>
    <updated>2019-05-12T08:57:13.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们再平时开发过程中，可能需要一些随机内容的字符串用于测试，例如：任意长度的内容字符串，测试我们的tableView的cell的高度自适应，这类测试有利于发现一些隐藏的bug。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-随机长度的字符串"><a href="#1-随机长度的字符串" class="headerlink" title="1.随机长度的字符串"></a>1.随机长度的字符串</h2><p>比较简单的做法是，有一个固定的字符串，我们去取其随机长度的子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;测试字符串&quot;;</span><br><span class="line">NSString *randomStr = [str substringToIndex:arc4random_uniform((uint32_t)(str.length))];</span><br></pre></td></tr></table></figure><h2 id="2-利用CCRandomGenerateBytes生成随机字符串"><a href="#2-利用CCRandomGenerateBytes生成随机字符串" class="headerlink" title="2.利用CCRandomGenerateBytes生成随机字符串"></a>2.利用CCRandomGenerateBytes生成随机字符串</h2><p>这个方法参考这里：<a href="https://blog.csdn.net/u012198553/article/details/78707197" target="_blank" rel="noopener">ios CCRandomGenerateBytes 生成定长随机字符串</a><br>可以生成任意长度的，随机的字母和数字组合的字符串，他本质是用作生成随机密钥的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//利用CCRandomGenerateBytes生成随机字符串</span><br><span class="line">+ (NSString *)jxt_randomStringWithLength:(size_t)length</span><br><span class="line">&#123;</span><br><span class="line">    if (length &lt; 1) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    length = length*0.5;</span><br><span class="line">    unsigned char digest[length];</span><br><span class="line">    CCRNGStatus status = CCRandomGenerateBytes(digest, length);</span><br><span class="line">    if (status == kCCSuccess) &#123;</span><br><span class="line">        return [self private_jxt_stringFrom:digest length:length];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将bytes转为字符串</span><br><span class="line">+ (NSString *)private_jxt_stringFrom:(unsigned char *)digest length:(size_t)length</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        [string appendFormat:@&quot;%02x&quot;,digest[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-指定位数随机数的生成"><a href="#3-指定位数随机数的生成" class="headerlink" title="3.指定位数随机数的生成"></a>3.指定位数随机数的生成</h2><p>这个一般用于验证码等随机密码的业务场合，常用的是生成4位或6位的随机数组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6位随机数</span><br><span class="line">[NSString stringWithFormat:@&quot;%06d&quot;, arc4random() % 1000000];</span><br><span class="line">//4位随机数</span><br><span class="line">[NSString stringWithFormat:@&quot;%04d&quot;, arc4random() % 10000];</span><br></pre></td></tr></table></figure><p>上述的算法比较简单，但是当我们需要长度更大的随机数字时，这个算法就有局限了，因为arc4random()的取值范围是0～4294967295，针对这个问题，我们可以改进一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)jxt_randomDigitsStringWithLength:(NSUInteger)length</span><br><span class="line">&#123;</span><br><span class="line">    NSString *randomDigits = @&quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">        randomDigits = [randomDigits stringByAppendingFormat:@&quot;%d&quot;, (arc4random() % 10)];</span><br><span class="line">    &#125;</span><br><span class="line">    return randomDigits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上述算法在性能上是比不上先前的两个的，所以要根据需求取舍。</p><p><strong>Demo详见：<a href="https://github.com/kukumaluCN/JXT_iOS_Demos/tree/master/RandomStringForTest">RandomStringForTest</a></strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u012198553/article/details/78707197" target="_blank" rel="noopener">ios CCRandomGenerateBytes 生成定长随机字符串</a></p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/13/随机内容字符串/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/13/随机内容字符串/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们再平时开发过程中，可能需要一些随机内容的字符串用于测试，例如：任意长度的内容字符串，测试我们的tableView的cell的高度自适应，
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="随机数" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>用结构体初始化大量布局常数</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/09/%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E9%87%8F%E5%B8%83%E5%B1%80%E5%B8%B8%E6%95%B0/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/09/用结构体初始化大量布局常数/</id>
    <published>2018-08-09T01:59:14.000Z</published>
    <updated>2019-05-12T08:57:13.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在平时UI适配开发中，可能会用到Masonry或者手写布局，在这些布局中，经常会用到一些常量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)addSubviewsConstraints</span><br><span class="line">    [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.top.mas_equalTo(self.view).offset(10);</span><br><span class="line">        make.width.height.mas_equalTo(100);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    self.myView.frame = CGRectMake(10, 10, 100, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只是两个固定值的例子，在Masonry中，<code>offset(10)</code>是一个间距值，对应手写frame布局就是<code>origin.x</code>和<code>origin.y</code>，这些值很可能是一些常数，一般不会更改，不过，如果肆意任这些常数散落在代码中，对于后期维护，可能会带来不小的麻烦。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="1-一般做法"><a href="#1-一般做法" class="headerlink" title="1.一般做法"></a>1.一般做法</h2><p>针对上述的麻烦，一般的做法是，布局时，统一初始化一些常数，后期维护，只是更改这些常数就好了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//布局常数</span><br><span class="line">CGFloat myViewLeftGap = 10, myViewTopGap = 10;</span><br><span class="line">CGSize myViewSize = CGSizeMake(100, 100);</span><br><span class="line">//Masonry</span><br><span class="line">- (void)addSubviewsConstraints</span><br><span class="line">    [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.mas_equalTo(self.view).offset(myViewLeftGap);</span><br><span class="line">        make.top.mas_equalTo(self.view).offset(myViewTopGap);</span><br><span class="line">        make.size.mas_equalTo(myViewSize);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">//frame</span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    self.myView.frame = CGRectMake(myViewLeftGap, myViewTopGap, myViewSize.width, myViewSize.height);</span><br><span class="line">    //或者</span><br><span class="line">    self.myView.frame = (CGRect)&#123;myViewLeftGap, myViewTopGap, myViewSize&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做看似麻烦，但是后期改起来，或者是调试bug时，我们只要关心常量的初始化部分就好了，不用再去看对应的布局代码，这就很省心了。</p><h2 id="2-使用结构体统一管理的优化"><a href="#2-使用结构体统一管理的优化" class="headerlink" title="2.使用结构体统一管理的优化"></a>2.使用结构体统一管理的优化</h2><p>上面的做法相对已经好了很多，但是，对于复杂的页面，页面的视图元素比较多时，这种方法会显得很臃肿，你要在布局代码前，初始化大量的常量，这种做法很不好，而且，在系统执行布局刷新时，对应的常数，再次被初始化了一遍，即便值没有更改，这就造成了不必要的开销。<br>对于这个问题，我们这里引入了结构体，结构体在iOS开发中，一般会很少使用，但其实系统中有很多例子，之前提到的<code>CGRect</code>和<code>CGSize</code>都是结构体这种数据结构。<br>下面是利用结构体对之前的做法的一种优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 声明布局常量结构体</span><br><span class="line"> */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    CGFloat myViewLeftGap;</span><br><span class="line">    CGFloat myViewTopGap;</span><br><span class="line">    CGSize myViewSize;</span><br><span class="line">&#125; MyLayoutConsts;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) UIView * myView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">&#123;</span><br><span class="line">    MyLayoutConsts _layout; //结构体全局变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Life Cycle</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //初始化结构体，结构体的初始化有很多种方式，我采用的这种，会显得比较清晰，便于修改</span><br><span class="line">    _layout = (MyLayoutConsts)&#123;</span><br><span class="line">        .myViewLeftGap = 20,</span><br><span class="line">        .myViewTopGap = 20,</span><br><span class="line">        .myViewSize = CGSizeMake(100, 100)</span><br><span class="line">    &#125;;</span><br><span class="line">    [self.view addSubview:self.myView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - UI</span><br><span class="line">- (void)viewWillLayoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillLayoutSubviews];</span><br><span class="line">    </span><br><span class="line">    self.myView.frame = (CGRect)&#123;_layout.myViewLeftGap, _layout.myViewTopGap, _layout.myViewSize&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Lazy Load</span><br><span class="line">- (UIView *)myView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_myView) &#123;</span><br><span class="line">        _myView = [[UIView alloc] initWithFrame:CGRectZero];</span><br><span class="line">        _myView.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _myView;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里使用<code>MyLayoutConsts _layout;</code>而没有使用属性，是为了节省调用get方法的开销，本质是一样的。<br>当然，这里要注意，<code>_layout.myViewLeftGap</code>语句本质上是<code>selg-&gt;_layout.myViewLeftGap</code>，所以要注意在block中的循环引用的问题。</p><p><strong>Demo详见<a href="https://github.com/kukumaluCN/JXT_iOS_Demos/tree/master/StructForLayoutDemo">StructForLayoutDemo</a></strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/qinqi376990311/article/details/73457506" target="_blank" rel="noopener">iOS开发中结构体的另一种“初始化方法”</a></li><li><a href="https://blog.csdn.net/github_26672553/article/details/50382188/" target="_blank" rel="noopener">结构体的4种初始化方式</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/09/用结构体初始化大量布局常数/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/09/用结构体初始化大量布局常数/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在平时UI适配开发中，可能会用到Masonry或者手写布局，在这些布局中，经常会用到一些常量，例如：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="结构体" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>一台电脑管理多个Git账户和SSH KEY</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/02/%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAGit%E8%B4%A6%E6%88%B7%E5%92%8CSSH-KEY/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/</id>
    <published>2018-08-02T12:26:27.000Z</published>
    <updated>2019-05-12T08:57:13.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时开发过程中可能遇到这样的问题，就是在进行公司的项目开发时要用公司的git账号，以及对应的git仓库，比如gitlab的；对于个人的开源项目，又会有自己的git账号，以及对应的git仓库，比如github或者码云（gitee）。<br>这时就会遇到多账户提交时的冲突问题，以及对应的多个ssh key的管理的问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-多个ssh-key的管理"><a href="#1-多个ssh-key的管理" class="headerlink" title="1.多个ssh key的管理"></a>1.多个ssh key的管理</h2><h3 id="1-1-ssh-key的创建"><a href="#1-1-ssh-key的创建" class="headerlink" title="1.1.ssh key的创建"></a>1.1.ssh key的创建</h3><p>假如有两个git账户，分别是<a href="mailto:`github@example.com" target="_blank" rel="noopener">`github@example.com</a><code>和</code><a href="mailto:gitee@example.com" target="_blank" rel="noopener">gitee@example.com</a>`。为了提交git，我们需要设置对应的ssh key，ssh key具体其在对应平台的配置方法比较简单，本文不再详述，可参考对应的资料，这里只是ssh key的创建及管理。<br>在终端输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "github@example.com"</span><br></pre></td></tr></table></figure><p>终端提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/XXX/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>此时直接回车，就会在<code>/Users/XXX/.ssh/</code>路径下，创建一个名为<code>id_rsa</code>的公钥，这个并不是我们想要的，因为这里要设计多个ssh key的管理，这个命名没有任何特征。</p><p>在终端中输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /Users/XXX/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>表示这个是github平台的key，之后根据终端提示，输入并确认密码，就可以生成了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /Users/XXX/.ssh/id_rsa_github.</span><br><span class="line">Your public key has been saved in /Users/XXX/.ssh/id_rsa_github.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>同理，另一个ssh key的创建流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "gitee@example.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): </span><br><span class="line"><span class="meta">$</span> /Users/XXX/.ssh/id_rsa_gitee</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /Users/XXX/.ssh/id_rsa_gitee.</span><br><span class="line">Your public key has been saved in /Users/XXX/.ssh/id_rsa_gitee.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="1-2-配置ssh代理"><a href="#1-2-配置ssh代理" class="headerlink" title="1.2.配置ssh代理"></a>1.2.配置ssh代理</h3><p>创建好了上面的多个ssh key就可以开始管理他们了。<br>在终端中输入如下命令，查询系统ssh key的代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -l</span><br></pre></td></tr></table></figure><p>如果系统已经设置了代理，需要删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -D</span><br><span class="line">All identities removed.</span><br></pre></td></tr></table></figure><p>如果提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> exec ssh-agent bash</span><br></pre></td></tr></table></figure><p>接下来添加刚才创建的ssh key的私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一个</span><br><span class="line"><span class="meta">$</span> ssh-add ~/.ssh/id_rsa_github</span><br><span class="line">Enter passphrase for /Users/XXX/.ssh/id_rsa_github: </span><br><span class="line">Identity added: /Users/XXX/.ssh/id_rsa_github (/Users/XXX/.ssh/id_rsa_github)</span><br><span class="line"></span><br><span class="line">//第二个</span><br><span class="line"><span class="meta">$</span> ssh-add ~/.ssh/id_rsa_gitee</span><br><span class="line">Enter passphrase for /Users/XXX/.ssh/id_rsa_gitee: </span><br><span class="line">Identity added: /Users/XXX/.ssh/id_rsa_gitee (/Users/XXX/.ssh/id_rsa_gitee)</span><br></pre></td></tr></table></figure><h3 id="1-3-添加公钥"><a href="#1-3-添加公钥" class="headerlink" title="1.3.添加公钥"></a>1.3.添加公钥</h3><p>其实就是将对应的.pub中的内容，复制到对应平台的ssh key管理栏目中，不同的平台，位置不同，可以去对应的个人中心的设置中查看，很容易找到。</p><h3 id="1-4-配置文件config"><a href="#1-4-配置文件config" class="headerlink" title="1.4.配置文件config"></a>1.4.配置文件config</h3><p>在/.ssh目录下创建config配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim ~/.ssh/config</span><br></pre></td></tr></table></figure><p>熟悉vim的可以直接在终端中编辑这个config文件，不熟悉的，打开指定目录下新创建的config文件，直接文本编辑即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> github配置</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> gitee配置</span><br><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_gitee</span><br></pre></td></tr></table></figure><p>编辑保存后，再次查看ssh key的代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -l</span><br></pre></td></tr></table></figure><p>如果看到如下，说明设置成功了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2048 SHA256:............ /Users/XXX/.ssh/id_rsa_github (RSA)</span><br><span class="line">2048 SHA256:............ /Users/XXX/.ssh/id_rsa_gitee (RSA)</span><br></pre></td></tr></table></figure><h3 id="1-5-验证ssh-key"><a href="#1-5-验证ssh-key" class="headerlink" title="1.5.验证ssh key"></a>1.5.验证ssh key</h3><p>终端中输入如下验证命令，如果返回如下，说明配置成功了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh -T git@github.com</span><br><span class="line">Hi XXXXXX! You've successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ssh -T git@gitee.com</span><br><span class="line">Hi XXXXXX! You've successfully authenticated, but Gitee.com does not provide shell access.</span><br></pre></td></tr></table></figure><p>如果遇到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission denied (publickey)</span><br></pre></td></tr></table></figure><p>就是之前的公钥设置的问题，需要去对应的平台检查下ssh key公钥是否设置成功。<br>至此，ssh key的配置管理就结束了。</p><h2 id="2-多个git账户的提交问题"><a href="#2-多个git账户的提交问题" class="headerlink" title="2.多个git账户的提交问题"></a>2.多个git账户的提交问题</h2><p>我们大多数人都会使用第三方工具进行git提交，比如source tree之类的，这些工具在提交时，如果不对对应的git仓库进行专门的配置，会默认走git的全局配置，也就是会用默认的全局配置的账户进行git提交。一不小心，就会用我们私人的账户，进行了公司项目的git提交，生成了对应的提交记录，也有可能因为权限问题，导致直接提交失败。<br>这时，我们需要对不同的仓库，进行对应的配置。</p><h3 id="2-1-检查全局配置"><a href="#2-1-检查全局配置" class="headerlink" title="2.1.检查全局配置"></a>2.1.检查全局配置</h3><p>在终端中，分别输入如下命令，可以检查目前电脑中的git的全局配置信息，如果没有返回，说明没有全局配置，如果有，就可以看到对应的默认的账户是那个了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.name</span><br><span class="line"><span class="meta">$</span> git config --global user.email</span><br></pre></td></tr></table></figure><p>为了避免麻烦，我们可以取消全局配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global --unset user.name</span><br><span class="line"><span class="meta">$</span> git config --global --unset user.email</span><br></pre></td></tr></table></figure><h3 id="2-2-全局配置和局部配置"><a href="#2-2-全局配置和局部配置" class="headerlink" title="2.2.全局配置和局部配置"></a>2.2.全局配置和局部配置</h3><p>此时已经取消了电脑中默认的git全局配置信息，此时进行git提交，会报对应的找不到账户信息的错误。<br>我们可以cd到对应的git仓库的根目录下，执行局部git配置命令。比如<code>/Users/XXX/github/DemoProject</code>是一个在github平台托管的本地git仓库的根目录，我们可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /Users/XXX/github/DemoProject</span><br><span class="line"><span class="meta">$</span> git config user.name</span><br><span class="line"><span class="meta">$</span> git config user.email</span><br></pre></td></tr></table></figure><p>如果返回均为空，说明没有进行过局部配置，可以分别配置github的账户名和邮箱：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config user.name "github账户名"</span><br><span class="line"><span class="meta">$</span> git config user.email "github@example.com"</span><br></pre></td></tr></table></figure><p>同理，在不同的git仓库下，可以分别配置不同平台的git账户名和git邮箱。这虽然看起来麻烦，不过，只要设置完成，之后只要不再更改对应的git仓库的路径，就不需要再更换配置了。<br><strong>而且，即便我们没有取消默认的全局git配置，在进行了局部配置后，后者的优先级会更高。</strong></p><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --list</span><br></pre></td></tr></table></figure><p>可以查看查看当前仓库的具体配置信息，在当前仓库目录下查看的配置是全局配置+当前项目的局部配置，<strong>使用的时候会优先使用当前仓库的局部配置，如果没有，才会去读取全局配置。</strong></p><h3 id="2-3-hexo部署时的git提交问题"><a href="#2-3-hexo部署时的git提交问题" class="headerlink" title="2.3.hexo部署时的git提交问题"></a>2.3.hexo部署时的git提交问题</h3><p>因为我们先前取消了电脑中的git全局配置，hexo在部署发布时，可能遇到如下问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email "you@example.com"</span><br><span class="line">  git config --global user.name "Your Name"</span><br><span class="line"></span><br><span class="line">to set your account's default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br></pre></td></tr></table></figure><p>不知道是不是因为hexo必须要求读取全局配置，设置了几个文件夹的局部git配置，均无效，只好又恢复了全局配置，也就是对应的github的账户信息，因为之前提到过，局部配置的优先级大于全局配置，所以不用担心账户冲突的问题，只要设置好对应仓库的局部配置信息，就不用担心全局配置的存在。<br>当然，这只是折中的方案，如果有人知道如何配置hexo仓库的局部配置信息，欢迎指教。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/wwmusic/article/details/51027458" target="_blank" rel="noopener">一台电脑如何管理多个SSH KEY</a></li><li><a href="https://www.jianshu.com/p/a869072a0092" target="_blank" rel="noopener">同一台电脑关于多个SSH KEY管理</a></li><li><a href="https://blog.csdn.net/yanzhenjie1003/article/details/69487932?locationNum=4&amp;fps=1" target="_blank" rel="noopener">Git管理多个SSH密钥，Git多帐号配置</a></li><li><a href="http://www.cnblogs.com/zichi/p/4704824.html" target="_blank" rel="noopener">如何配置多个ssh key</a></li><li><a href="https://blog.csdn.net/baidu_35738377/article/details/54580156" target="_blank" rel="noopener">Git配置多账号登录不同项目</a></li><li><a href="https://blog.csdn.net/luohai859/article/details/50679859" target="_blank" rel="noopener">Git全局配置和单个仓库的用户名邮箱配置</a></li><li><a href="https://www.cnblogs.com/chenwolong/p/GIT.html" target="_blank" rel="noopener">GIT 常用命令</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时开发过程中可能遇到这样的问题，就是在进行公司的项目开发时要用公司的git账号，以及对应的git仓库，比如gitlab的；对于个人的开源项
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Git" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/Git/"/>
    
    
      <category term="Git" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/Git/"/>
    
      <category term="SSH KEY" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/SSH-KEY/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods中PBXSourcesBuildPhase unknown UUID的错误解决</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods%E4%B8%ADPBXSourcesBuildPhase-unknown-UUID%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/</id>
    <published>2018-08-01T09:07:01.000Z</published>
    <updated>2019-05-13T09:04:28.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>在执行<code>pod install</code>命令时，出现了如下的警告：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[!] `&lt;PBXResourcesBuildPhase UUID=`XXX`&gt;` </span><br><span class="line">attempted to initialize an object with an </span><br><span class="line">unknown UUID. `XXX` for attribute: `files`. </span><br><span class="line">This can be the result of a merge and  the </span><br><span class="line">unknown UUID is being discarded.</span><br></pre></td></tr></table></figure></p><p>解决方式如下：</p><ul><li>1.打开项目-&gt;Target-&gt;General-&gt;Linked Frameworks and Libraries，选中libpods-XXX.a，XXX是指你的项目名称，点“-”删除。</li><li>2.退出Xcode</li><li>3.重新执行pod install</li></ul><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513170337.png" alt="libpoda"></p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;在执行&lt;code&gt;pod install&lt;/code&gt;命令时，出现了如下的警告：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods中的Smart quotes were detected...警告</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods%E4%B8%AD%E7%9A%84Smart-quotes-were-detected-%E8%AD%A6%E5%91%8A/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/</id>
    <published>2018-08-01T08:46:36.000Z</published>
    <updated>2019-05-12T08:57:13.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>在执行<code>pod install</code>命令时，出现了如下的警告：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[!] Smart quotes were detected and ignored in </span><br><span class="line">your Podfile. To avoid issues in the future, </span><br><span class="line">you should not use TextEdit for editing it. </span><br><span class="line">If you are not using TextEdit, you should </span><br><span class="line">turn off smart quotes in your editor of choice.</span><br></pre></td></tr></table></figure></p><p>大致的意思是：在Podfile文件中，引号被智能的检测到并被忽略。</p><p>通过检查Podfile文件，发现了如下代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Demo’ do</span></span><br></pre></td></tr></table></figure><p>这明显是因为输入法切换导致的右引号写成了中文的单引号，这个问题很难被发现，即便没什么影响，但是改一下就可以消除警告，何乐为不为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;在执行&lt;code&gt;pod install&lt;/code&gt;命令时，出现了如下的警告：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发Tips" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>UIViewController继承时父子类方法重名造成的一个crash</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/31/UIViewController%E7%BB%A7%E6%89%BF%E6%97%B6%E7%88%B6%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%B8%AAcrash/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/</id>
    <published>2018-07-31T05:30:44.000Z</published>
    <updated>2019-05-13T09:00:12.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发过程中，遇到了一个因为UIViewController继承时父子类方法重名造成的一个crash问题，本文是问题的原因分析和解决方法。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="1-一个crash问题的分析"><a href="#1-一个crash问题的分析" class="headerlink" title="1.一个crash问题的分析"></a>1.一个crash问题的分析</h2><p>有如下父子类，<code>SubViewController</code>继承于<code>BaseViewController</code>，父子类中均有<code>-addConstraintsForSubviews</code>这个重名的私有方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">@implementation BaseViewController</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];    </span><br><span class="line">    //添加子视图</span><br><span class="line">    [self base_lazyLoadSubviews];</span><br><span class="line">    //添加约束</span><br><span class="line">    [self addConstraintsForSubviews];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//子类</span><br><span class="line">@implementation SubViewController</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];    </span><br><span class="line">    //添加子视图</span><br><span class="line">    [self sub_lazyLoadSubviews];</span><br><span class="line">    //添加约束</span><br><span class="line">    [self addConstraintsForSubviews];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>实际运行过程中，遇到了如下的crash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception </span><br><span class="line">&apos;NSInvalidArgumentException&apos;, reason: </span><br><span class="line">&apos;NSLayoutConstraint for &lt;UIImageView: </span><br><span class="line">0x10bee7fa0; frame = (0 0; 0 0); opaque = NO; </span><br><span class="line">userInteractionEnabled = NO; layer = &lt;CALayer: </span><br><span class="line">0x17023ba00&gt;&gt;: A multiplier of 0 or a nil </span><br><span class="line">second item together with a location for the </span><br><span class="line">first attribute creates an illegal constraint </span><br><span class="line">of a location equal to a constant. Location </span><br><span class="line">attributes must be specified in pairs.&apos;</span><br></pre></td></tr></table></figure><p>上述的<code>-addConstraintsForSubviews</code>方法中有用到AutoLayout做自动布局，crash也是因为自动布局导致的。<br>经过断点调试，也就是走了一遍ViewController的生命周期方法，分析出了这个crash的原因：</p><ul><li>1.子类执行<code>-viewDidLoad</code>时，调用了<code>[super viewDidLoad]</code>，触发父类的<code>-viewDidLoad</code>。</li><li>2.父类的<code>-viewDidLoad</code>方法中实现了基础的UI加载和布局，也就是父类对应的<code>-base_lazyLoadSubviews</code>和<code>-addConstraintsForSubviews</code>这两个方法。</li><li>3.当父类执行这两个方法时，其实就已经有问题了，因为子类有同名的<code>-addConstraintsForSubviews</code>方法，导致父类的方法实现被子类覆盖了，此时父类会去调用子类的<code>-addConstraintsForSubviews</code>去布局。</li><li>4.子类此时还没有执行<code>-sub_lazyLoadSubviews</code>方法，也就是子类的视图控件还没有添加到父视图上，此时执行AutoLayout，就造成了crash。</li></ul><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>在父类增加一些共有的UI组件，某些情况下可以简化开发，但其实更多的时候，并没有省却很多麻烦。个人建议还是不要在公有的父类中增加过多的UI特性，以免日后更多的不必要的麻烦，子类过多，已经足够引起你的重视了。当然如果只是项目中的基类，用作埋点或其他用途，那么增加其他的UI特性，更是不合适的了。<br>下面只是基于上述问题，提出对应的解决方案。</p><h3 id="2-1-规范命名"><a href="#2-1-规范命名" class="headerlink" title="2.1.规范命名"></a>2.1.规范命名</h3><p>这其实是算是一个命名不规范导致的问题，如果是父类私有的方法，还是增加前缀比较安全，所以最简单的解决方式就是改名：<br><code>-base_addConstraintsForSubviews</code><br><code>-sub_addConstraintsForSubviews</code></p><h3 id="2-2-更加优雅的解决方式"><a href="#2-2-更加优雅的解决方式" class="headerlink" title="2.2.更加优雅的解决方式"></a>2.2.更加优雅的解决方式</h3><p>上一种方法其实并不是很好，因为可能遇到其他开发者继承于你的父类的问题，如果每次都要告知对方去注意这些问题，就很容易出问题了。<br>这里提出一种参考系统的生命周期方法中回调父类的方式去解决这个问题。<br>在父类中的头文件，声明子类容易覆写的同类型方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface BaseViewController : UIViewController</span><br><span class="line">- (void)lazyLoadSubviews NS_REQUIRES_SUPER;</span><br><span class="line">- (void)addConstraintsForSubviews NS_REQUIRES_SUPER;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>方法声明过程中，使用了系统的宏<code>NS_REQUIRES_SUPER</code>来修饰，表示子类覆写该方法时，必须在方法内部调用super的这个方法，否则会有如下的警告（以系统的<code>UITableViewCell</code>的<code>-prepareForReuse</code>方法为例）：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513165930.png" alt="UIViewController继承时父子类方法重名造成的一个crash-NS_REQUIRES_SUPE"></p><p>这样即便子类使用者在不知情的情况下，覆写了父类的同名方法，也会有警告提示，只要执行了父类的同名方法，就可以避免上述的问题发生。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/shihuboke/article/details/78200339" target="_blank" rel="noopener">iOS 修饰符~ NS_UNAVAILABLE、NS_REQUIRES_SUPER</a></li><li><a href="https://www.dudas.co.uk/ns_requires_super/" target="_blank" rel="noopener">NS_REQUIRES_SUPER</a></li></ol><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在开发过程中，遇到了一个因为UIViewController继承时父子类方法重名造成的一个crash问题，本文是问题的原因分析和解决方法
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/"/>
    
      <category term="开发随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/iOS/"/>
    
      <category term="继承" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/30/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/30/Hexo-Github搭建个人博客/</id>
    <published>2018-07-30T06:59:56.000Z</published>
    <updated>2019-05-13T08:59:21.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍了在Mac环境下，通过Hexo+Github搭建个人博客的完整操作流程，笔者参考了部分现有的文章，通过实践，排除了一些坑，并多次尝试后，整理出本文。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h2><p>通过Homebrew安装，会很便捷，但是事后遇到了重启终端，执行<code>nvm</code>命令，报<code>-bash: npm: command not found</code>错误，只好重头做起，在<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>官网下载包安装，也很方便。<br><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">5分钟 搭建免费个人博客</a>一文中提到的，使用Homebrew安装Node.js的命令如下，请注意其中的注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install nvm</span><br><span class="line"><span class="meta">$</span> mkdir ~/.nvm</span><br><span class="line"><span class="meta">$</span> export NVM_DIR=~/.nvm</span><br><span class="line"><span class="meta">$</span> . $(brew --prefix nvm)/nvm.sh</span><br><span class="line"><span class="meta">$</span> nvm install 4 //这里是大坑，这个指定了安装的版本，截止到本文书写时，node的版本已经到8.x了</span><br></pre></td></tr></table></figure><p>个人建议还是直接去官网下载包安装。</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>这个是提交之后的内容必备的，Mac自带了git，就不再赘述。</p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>终端命令如下（Hexo官网上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时要在前面加上sudo，否则会因为权限问题报错）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="4-初始化Hexo"><a href="#4-初始化Hexo" class="headerlink" title="4.初始化Hexo"></a>4.初始化Hexo</h2><p>终端cd到自己选定的一个文件夹（之后所有的hexo相关的文件都将安装在文件夹中）的上一层级目录（选定的文件夹包含于该层级下），执行hexo init命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /Users/...</span><br><span class="line"><span class="meta">$</span> hexo init XXX //XXX是对应的自己建立的文件夹的名字，用于存放之后关于hexo的所有文件</span><br></pre></td></tr></table></figure><p>cd到XXX文件夹下，安装npm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd XXX</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure><h2 id="5-测试hexo"><a href="#5-测试hexo" class="headerlink" title="5.测试hexo"></a>5.测试hexo</h2><p>执行命令，开启hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo s</span><br></pre></td></tr></table></figure><p>执行命令后，在浏览器中访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><br>看到下面的页面，说明本地访问成功，hexo的初始化工作结束：</p><p><img src="https://raw.githubusercontent.com/kukumaluCN/kukumalu-open-images/master/blog/20190513165735.png" alt="Hexo-Github搭建个人博客-测试hexo"></p><p>执行下面的命令可以停止测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> Ctrl+C</span><br></pre></td></tr></table></figure><h2 id="6-建立Github关联的仓库"><a href="#6-建立Github关联的仓库" class="headerlink" title="6.建立Github关联的仓库"></a>6.建立Github关联的仓库</h2><p>在github新建一个仓库，仓库名固定为<code>github用户名.github.io</code>。</p><p>例如笔者的就是：<a href="https://github.com/kukumaluCN/kukumaluCN.github.io">kukumaluCN.github.io</a></p><p>获取到仓库的地址和git地址，后面使用。</p><h2 id="7-配置-config-yml文件"><a href="#7-配置-config-yml文件" class="headerlink" title="7.配置_config.yml文件"></a>7.配置_config.yml文件</h2><p>在之前的XXX文件夹下，有<code>_config.yml</code>文件，该文件是hexo的配置信息，因为不同版本，该文件的信息会有变化，所以网上的很多教程都不太适用，需要自己综合参考修改，下面的是根据笔者当前的配置列出的示例。</p><p>需要修改的基本信息如下，如果有其他需要，可以参考官网<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo配置</a>自行修改（注意冒号后面必须有空格）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 霖溦之境 #Hexo 博客标题</span><br><span class="line">subtitle: 霖溦的个人博客 #博客副标题</span><br><span class="line">description: 霖溦的个人博客</span><br><span class="line">author: 霖溦 #作者名</span><br><span class="line">language: zh-Hans #中文</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://github.com/kukumaluCN/kukumaluCN.github.io #github仓库的地址</span><br><span class="line">root: /</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2 id="8-安装hexo-deployer-git自动部署发布工具"><a href="#8-安装hexo-deployer-git自动部署发布工具" class="headerlink" title="8.安装hexo-deployer-git自动部署发布工具"></a>8.安装hexo-deployer-git自动部署发布工具</h2><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="9-发布hexo"><a href="#9-发布hexo" class="headerlink" title="9.发布hexo"></a>9.发布hexo</h2><p>修改完上述配置后，可以再次hexo s执行一次测试，看看修改后的效果。没有问题就可以发布了。</p><p>在XXX文件夹下生成静态页面，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>这是三个命令，clean是清理缓存，g就是generate生成静态文件，d是deploy也就是最终的部署。</p><p>具体的命令参考官网：<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo指令</a></p><p>执行上述命令时，可能因为没有关联github提示输入github的用户名和密码（<strong>参考第10条，可能是deploy中repo的设置问题，改成ssh就不会遇到该提示了，前提是你的github绑定了ssh key</strong>）。</p><h2 id="10-发布文章"><a href="#10-发布文章" class="headerlink" title="10.发布文章"></a>10.发布文章</h2><p>cd到XXX目录下，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo new "title" //title是要发布的文章的标题</span><br></pre></td></tr></table></figure><p>title是要发布的文章的标题，具体规范参考<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo指令</a>中关于new的一项。</p><p>执行之后，会在/XXX/source/_posts路径下生成“title.md”文件，具体的书写就是标准的markdown语法了，可以自行使用习惯的md编辑器书写。</p><p>文章编辑完之后执行如下命令发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>期间遇到了如下错误：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for &apos;https://github.com/kukumaluCN/kukumaluCN.github.io.git/&apos;</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure><p>本以为是SSH key的问题，结果发现设置过了，经过实验，发现是配置文件的问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Deployment</span><br><span class="line"><span class="meta">#</span># Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line"><span class="meta">#</span>repo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址</span><br><span class="line">repo: git@github.com:kukumaluCN/kukumaluCN.github.io.git #改成ssh地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2 id="11-更换主题"><a href="#11-更换主题" class="headerlink" title="11.更换主题"></a>11.更换主题</h2><p>Hexo的主题有很多，具体参考：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Thems</a><br>这里以<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">maupassant</a>主题为例：<br>cd XXX到刚才的目录。<br>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line"><span class="meta">$</span> npm install hexo-renderer-pug --save</span><br><span class="line"><span class="meta">$</span> npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><p>再次修改配置文件_config.yml，将theme的值改为maupassant。<br>编辑完之后执行如下命令发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">5分钟 搭建免费个人博客</a></li><li><a href="https://www.jianshu.com/p/13e64c9e2295" target="_blank" rel="noopener">Mac上搭建基于GitHub的Hexo博客</a></li><li><a href="https://yegod.github.io/blog-1/" target="_blank" rel="noopener">如何搭建自己的博客</a></li></ol><hr><blockquote><p><strong>本文作者：</strong> 霖溦<br><strong>本文链接：</strong> <a href="https://kukumalucn.github.io/blog/2018/07/30/Hexo-Github搭建个人博客/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/07/30/Hexo-Github搭建个人博客/</a><br><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要介绍了在Mac环境下，通过Hexo+Github搭建个人博客的完整操作流程，笔者参考了部分现有的文章，通过实践，排除了一些坑，并多次
      
    
    </summary>
    
      <category term="技术博客" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于霖溦之境</title>
    <link href="https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/27/%E5%85%B3%E4%BA%8E%E9%9C%96%E6%BA%A6%E4%B9%8B%E5%A2%83/"/>
    <id>https://github.com/kukumaluCN/kukumaluCN.github.io//blog/2018/07/27/关于霖溦之境/</id>
    <published>2018-07-27T09:34:16.000Z</published>
    <updated>2019-05-12T08:57:13.823Z</updated>
    
    <content type="html"><![CDATA[<p>这里是霖溦的个人博客，从今天开始将在这里陆续更新博文，博文内容不限于iOS开发技术，也包含个人爱好的点滴。</p><p><strong>写于 2018.7.27</strong></p><hr><blockquote><p><strong>本文作者：</strong>霖溦<br><strong>本文链接：</strong><a href="https://kukumalucn.github.io/blog/2018/07/27/关于霖溦之境/" target="_blank" rel="noopener">https://kukumalucn.github.io/blog/2018/07/27/关于霖溦之境/</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">CC BY-NC-ND 4.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是霖溦的个人博客，从今天开始将在这里陆续更新博文，博文内容不限于iOS开发技术，也包含个人爱好的点滴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写于 2018.7.27&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong
      
    
    </summary>
    
      <category term="随笔" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="介绍" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/categories/%E9%9A%8F%E7%AC%94/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="关于" scheme="https://github.com/kukumaluCN/kukumaluCN.github.io/tags/%E5%85%B3%E4%BA%8E/"/>
    
  </entry>
  
</feed>
