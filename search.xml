<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cocoapods的版本升级和降级]]></title>
    <url>%2F%2Fblog%2F2018%2F09%2F20%2FCocoapods%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Tips在平时开发中，有时可能会遇到Cocoapods的版本的问题，我们实际使用的版本可能会因为过低而导致各种问题，这时需要升级，有时又会因为某个开源库不支持最新的Cocoapods版本而不得不降级我们本地的Cocoapods。 1.升级 升级比较简单，实际命令如下： 1$ sudo gem install -n /usr/local/bin cocoapods -v 1.5.3 -v后面是版本号，当前Cocoapods的release版为1.5.3。输入密码之后即可执行升级操作。升级结束后，可以查看下当前的pod版本: 1234//执行命令查看版本信息$ pod --version//输出的版本号是最新的1.5.3 2.切换Ruby源 执行上述命令时，可能会遇到如下的错误： 12ERROR: Could not find a valid gem 'cocoapods' (= 1.5.3), here is why: Unable to download data from https://gems.ruby-china.org/ - bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz) 这是因为之前在配置Cocoapods时，本地的源设置的问题，这篇文章写下时，RubyGems的国内镜像已经变成了：https://gems.ruby-china.com。我们需要手动切换一下： 123456//查询本地源的列表$ gem sources -l//删除已经不能使用的源$ gem sources --remove https://gems.ruby-china.org///添加最新的源$ gem sources -a https://gems.ruby-china.com 123456//再次查询$ gem sources -l//可以看下如下信息，表示切换成功：*** CURRENT SOURCES ***https://gems.ruby-china.com 3.降级 和执行升级操作一样，比如想要安装1.5.0版本，执行如下命令： 1$ sudo gem install -n /usr/local/bin cocoapods -v 1.5.0 提示安装成功后，再次查询版本号： 1234//执行命令查看版本信息$ pod --version//输出的版本号依旧是最新的1.5.3 这是因为本地安装了多个版本的cocoapods，默认使用最新的版本，想要切换低版本，可以执行如下操作： 123456789101112131415161718192021//执行卸载命令$ sudo gem uninstall cocoapods//提示卸载哪一版本，并列出本地安装过的所有版本Select gem to uninstall: 1. cocoapods-1.1.1 2. cocoapods-1.2.1 3. cocoapods-1.3.1 4. cocoapods-1.5.0 5. cocoapods-1.5.3 6. All versions//输入5，卸载最新的那一版本&gt; 5//提示卸载成功Successfully uninstalled cocoapods-1.5.3//查询版本号，可以看到此时使用的是1.5.0，也就是当前最新的版本了$ pod --version1.5.0 除了上述的方法，还可以: 12345678//列出所有信息$ gem list//找到此项cocoapods (1.1.1, 1.2.1, 1.3.1, 1.5.0, 1.5.3)//移除指定版本cocoapods$ sudo gem uninstall cocoapods -v 1.5.3 参考 安装CocoaPods 出现这样的问题 升级 Cocoapods 到1.2.0指定版本，降低版本及卸载 iOS开发中如何管理多个版本的Cocoapods、gem cocoapods 卸载,重装,高版本的使用 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/09/20/Cocoapods的版本升级和降级/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机内容字符串]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F13%2F%E9%9A%8F%E6%9C%BA%E5%86%85%E5%AE%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前言我们再平时开发过程中，可能需要一些随机内容的字符串用于测试，例如：任意长度的内容字符串，测试我们的tableView的cell的高度自适应，这类测试有利于发现一些隐藏的bug。 正文1.随机长度的字符串比较简单的做法是，有一个固定的字符串，我们去取其随机长度的子串。 12NSString *str = @&quot;测试字符串&quot;;NSString *randomStr = [str substringToIndex:arc4random_uniform((uint32_t)(str.length))]; 2.利用CCRandomGenerateBytes生成随机字符串这个方法参考这里：ios CCRandomGenerateBytes 生成定长随机字符串可以生成任意长度的，随机的字母和数字组合的字符串，他本质是用作生成随机密钥的。 12345678910111213141516171819202122232425//利用CCRandomGenerateBytes生成随机字符串+ (NSString *)jxt_randomStringWithLength:(size_t)length&#123; if (length &lt; 1) &#123; return nil; &#125; length = length*0.5; unsigned char digest[length]; CCRNGStatus status = CCRandomGenerateBytes(digest, length); if (status == kCCSuccess) &#123; return [self private_jxt_stringFrom:digest length:length]; &#125; return nil;&#125;//将bytes转为字符串+ (NSString *)private_jxt_stringFrom:(unsigned char *)digest length:(size_t)length&#123; NSMutableString *string = [NSMutableString string]; for (int i = 0; i &lt; length; i++) &#123; [string appendFormat:@&quot;%02x&quot;,digest[i]]; &#125; return string;&#125; 3.指定位数随机数的生成这个一般用于验证码等随机密码的业务场合，常用的是生成4位或6位的随机数组合： 1234//6位随机数[NSString stringWithFormat:@&quot;%06d&quot;, arc4random() % 1000000];//4位随机数[NSString stringWithFormat:@&quot;%04d&quot;, arc4random() % 10000]; 上述的算法比较简单，但是当我们需要长度更大的随机数字时，这个算法就有局限了，因为arc4random()的取值范围是0～4294967295，针对这个问题，我们可以改进一下： 12345678+ (NSString *)jxt_randomDigitsStringWithLength:(NSUInteger)length&#123; NSString *randomDigits = @&quot;&quot;; for (int i = 0; i &lt; length; i ++) &#123; randomDigits = [randomDigits stringByAppendingFormat:@&quot;%d&quot;, (arc4random() % 10)]; &#125; return randomDigits;&#125; 当然上述算法在性能上是比不上先前的两个的，所以要根据需求取舍。 Demo详见：RandomStringForTest 参考ios CCRandomGenerateBytes 生成定长随机字符串 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/13/随机内容字符串/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用结构体初始化大量布局常数]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F09%2F%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E9%87%8F%E5%B8%83%E5%B1%80%E5%B8%B8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言在平时UI适配开发中，可能会用到Masonry或者手写布局，在这些布局中，经常会用到一些常量，例如： 123456- (void)addSubviewsConstraints [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.top.mas_equalTo(self.view).offset(10); make.width.height.mas_equalTo(100); &#125;];&#125; 或者： 12345- (void)layoutSubviews&#123; [super layoutSubviews]; self.myView.frame = CGRectMake(10, 10, 100, 100);&#125; 上面只是两个固定值的例子，在Masonry中，offset(10)是一个间距值，对应手写frame布局就是origin.x和origin.y，这些值很可能是一些常数，一般不会更改，不过，如果肆意任这些常数散落在代码中，对于后期维护，可能会带来不小的麻烦。 内容1.一般做法针对上述的麻烦，一般的做法是，布局时，统一初始化一些常数，后期维护，只是更改这些常数就好了。例如： 12345678910111213141516171819//布局常数CGFloat myViewLeftGap = 10, myViewTopGap = 10;CGSize myViewSize = CGSizeMake(100, 100);//Masonry- (void)addSubviewsConstraints [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.mas_equalTo(self.view).offset(myViewLeftGap); make.top.mas_equalTo(self.view).offset(myViewTopGap); make.size.mas_equalTo(myViewSize); &#125;];&#125;//frame- (void)layoutSubviews&#123; [super layoutSubviews]; self.myView.frame = CGRectMake(myViewLeftGap, myViewTopGap, myViewSize.width, myViewSize.height); //或者 self.myView.frame = (CGRect)&#123;myViewLeftGap, myViewTopGap, myViewSize&#125;;&#125; 这样做看似麻烦，但是后期改起来，或者是调试bug时，我们只要关心常量的初始化部分就好了，不用再去看对应的布局代码，这就很省心了。 2.使用结构体统一管理的优化上面的做法相对已经好了很多，但是，对于复杂的页面，页面的视图元素比较多时，这种方法会显得很臃肿，你要在布局代码前，初始化大量的常量，这种做法很不好，而且，在系统执行布局刷新时，对应的常数，再次被初始化了一遍，即便值没有更改，这就造成了不必要的开销。对于这个问题，我们这里引入了结构体，结构体在iOS开发中，一般会很少使用，但其实系统中有很多例子，之前提到的CGRect和CGSize都是结构体这种数据结构。下面是利用结构体对之前的做法的一种优化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 声明布局常量结构体 */typedef struct &#123; CGFloat myViewLeftGap; CGFloat myViewTopGap; CGSize myViewSize;&#125; MyLayoutConsts;@interface ViewController ()@property (nonatomic, strong) UIView * myView;@end@implementation ViewController&#123; MyLayoutConsts _layout; //结构体全局变量&#125;#pragma mark - Life Cycle- (void)viewDidLoad&#123; [super viewDidLoad]; //初始化结构体，结构体的初始化有很多种方式，我采用的这种，会显得比较清晰，便于修改 _layout = (MyLayoutConsts)&#123; .myViewLeftGap = 20, .myViewTopGap = 20, .myViewSize = CGSizeMake(100, 100) &#125;; [self.view addSubview:self.myView];&#125;#pragma mark - UI- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; self.myView.frame = (CGRect)&#123;_layout.myViewLeftGap, _layout.myViewTopGap, _layout.myViewSize&#125;;&#125;#pragma mark - Lazy Load- (UIView *)myView&#123; if (!_myView) &#123; _myView = [[UIView alloc] initWithFrame:CGRectZero]; _myView.backgroundColor = [UIColor redColor]; &#125; return _myView;&#125;@end 这里使用MyLayoutConsts _layout;而没有使用属性，是为了节省调用get方法的开销，本质是一样的。当然，这里要注意，_layout.myViewLeftGap语句本质上是selg-&gt;_layout.myViewLeftGap，所以要注意在block中的循环引用的问题。 Demo详见StructForLayoutDemo 参考 iOS开发中结构体的另一种“初始化方法” 结构体的4种初始化方式 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/09/用结构体初始化大量布局常数/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一台电脑管理多个Git账户和SSH KEY]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F02%2F%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAGit%E8%B4%A6%E6%88%B7%E5%92%8CSSH-KEY%2F</url>
    <content type="text"><![CDATA[前言平时开发过程中可能遇到这样的问题，就是在进行公司的项目开发时要用公司的git账号，以及对应的git仓库，比如gitlab的；对于个人的开源项目，又会有自己的git账号，以及对应的git仓库，比如github或者码云（gitee）。这时就会遇到多账户提交时的冲突问题，以及对应的多个ssh key的管理的问题。 正文1.多个ssh key的管理1.1.ssh key的创建假如有两个git账户，分别是`github@example.com和gitee@example.com`。为了提交git，我们需要设置对应的ssh key，ssh key具体其在对应平台的配置方法比较简单，本文不再详述，可参考对应的资料，这里只是ssh key的创建及管理。在终端输入如下命令： 1$ ssh-keygen -t rsa -C "github@example.com" 终端提示如下： 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): 此时直接回车，就会在/Users/XXX/.ssh/路径下，创建一个名为id_rsa的公钥，这个并不是我们想要的，因为这里要设计多个ssh key的管理，这个命名没有任何特征。 在终端中输入如下命令： 1$ /Users/XXX/.ssh/id_rsa_github 表示这个是github平台的key，之后根据终端提示，输入并确认密码，就可以生成了。 123456Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/XXX/.ssh/id_rsa_github.Your public key has been saved in /Users/XXX/.ssh/id_rsa_github.pub.The key fingerprint is:... 同理，另一个ssh key的创建流程如下： 12345678910$ ssh-keygen -t rsa -C "gitee@example.com"Generating public/private rsa key pair.Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): $ /Users/XXX/.ssh/id_rsa_giteeEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/XXX/.ssh/id_rsa_gitee.Your public key has been saved in /Users/XXX/.ssh/id_rsa_gitee.pub.The key fingerprint is:... 1.2.配置ssh代理创建好了上面的多个ssh key就可以开始管理他们了。在终端中输入如下命令，查询系统ssh key的代理： 1$ ssh-add -l 如果系统已经设置了代理，需要删除： 12$ ssh-add -DAll identities removed. 如果提示： 1Could not open a connection to your authentication agent. 执行： 1$ exec ssh-agent bash 接下来添加刚才创建的ssh key的私钥： 123456789//第一个$ ssh-add ~/.ssh/id_rsa_githubEnter passphrase for /Users/XXX/.ssh/id_rsa_github: Identity added: /Users/XXX/.ssh/id_rsa_github (/Users/XXX/.ssh/id_rsa_github)//第二个$ ssh-add ~/.ssh/id_rsa_giteeEnter passphrase for /Users/XXX/.ssh/id_rsa_gitee: Identity added: /Users/XXX/.ssh/id_rsa_gitee (/Users/XXX/.ssh/id_rsa_gitee) 1.3.添加公钥其实就是将对应的.pub中的内容，复制到对应平台的ssh key管理栏目中，不同的平台，位置不同，可以去对应的个人中心的设置中查看，很容易找到。 1.4.配置文件config在/.ssh目录下创建config配置文件： 1$ vim ~/.ssh/config 熟悉vim的可以直接在终端中编辑这个config文件，不熟悉的，打开指定目录下新创建的config文件，直接文本编辑即可： 1234567891011# github配置Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_github# gitee配置Host gitee.com HostName gitee.com User git IdentityFile ~/.ssh/id_rsa_gitee 编辑保存后，再次查看ssh key的代理： 1$ ssh-add -l 如果看到如下，说明设置成功了： 122048 SHA256:............ /Users/XXX/.ssh/id_rsa_github (RSA)2048 SHA256:............ /Users/XXX/.ssh/id_rsa_gitee (RSA) 1.5.验证ssh key终端中输入如下验证命令，如果返回如下，说明配置成功了： 12345$ ssh -T git@github.comHi XXXXXX! You've successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@gitee.comHi XXXXXX! You've successfully authenticated, but Gitee.com does not provide shell access. 如果遇到： 1permission denied (publickey) 就是之前的公钥设置的问题，需要去对应的平台检查下ssh key公钥是否设置成功。至此，ssh key的配置管理就结束了。 2.多个git账户的提交问题我们大多数人都会使用第三方工具进行git提交，比如source tree之类的，这些工具在提交时，如果不对对应的git仓库进行专门的配置，会默认走git的全局配置，也就是会用默认的全局配置的账户进行git提交。一不小心，就会用我们私人的账户，进行了公司项目的git提交，生成了对应的提交记录，也有可能因为权限问题，导致直接提交失败。这时，我们需要对不同的仓库，进行对应的配置。 2.1.检查全局配置在终端中，分别输入如下命令，可以检查目前电脑中的git的全局配置信息，如果没有返回，说明没有全局配置，如果有，就可以看到对应的默认的账户是那个了。 12$ git config --global user.name$ git config --global user.email 为了避免麻烦，我们可以取消全局配置： 12$ git config --global --unset user.name$ git config --global --unset user.email 2.2.全局配置和局部配置此时已经取消了电脑中默认的git全局配置信息，此时进行git提交，会报对应的找不到账户信息的错误。我们可以cd到对应的git仓库的根目录下，执行局部git配置命令。比如/Users/XXX/github/DemoProject是一个在github平台托管的本地git仓库的根目录，我们可以执行如下命令： 123$ cd /Users/XXX/github/DemoProject$ git config user.name$ git config user.email 如果返回均为空，说明没有进行过局部配置，可以分别配置github的账户名和邮箱： 12$ git config user.name "github账户名"$ git config user.email "github@example.com" 同理，在不同的git仓库下，可以分别配置不同平台的git账户名和git邮箱。这虽然看起来麻烦，不过，只要设置完成，之后只要不再更改对应的git仓库的路径，就不需要再更换配置了。而且，即便我们没有取消默认的全局git配置，在进行了局部配置后，后者的优先级会更高。 执行： 1$ git config --list 可以查看查看当前仓库的具体配置信息，在当前仓库目录下查看的配置是全局配置+当前项目的局部配置，使用的时候会优先使用当前仓库的局部配置，如果没有，才会去读取全局配置。 2.3.hexo部署时的git提交问题因为我们先前取消了电脑中的git全局配置，hexo在部署发布时，可能遇到如下问题： 123456789*** Please tell me who you are.Run git config --global user.email "you@example.com" git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository. 不知道是不是因为hexo必须要求读取全局配置，设置了几个文件夹的局部git配置，均无效，只好又恢复了全局配置，也就是对应的github的账户信息，因为之前提到过，局部配置的优先级大于全局配置，所以不用担心账户冲突的问题，只要设置好对应仓库的局部配置信息，就不用担心全局配置的存在。当然，这只是折中的方案，如果有人知道如何配置hexo仓库的局部配置信息，欢迎指教。 参考 一台电脑如何管理多个SSH KEY 同一台电脑关于多个SSH KEY管理 Git管理多个SSH密钥，Git多帐号配置 如何配置多个ssh key Git配置多账号登录不同项目 Git全局配置和单个仓库的用户名邮箱配置 GIT 常用命令 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SSH KEY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods中PBXSourcesBuildPhase unknown UUID的错误解决]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F01%2FCocoaPods%E4%B8%ADPBXSourcesBuildPhase-unknown-UUID%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Tips在执行pod install命令时，出现了如下的警告：12345[!] `&lt;PBXResourcesBuildPhase UUID=`XXX`&gt;` attempted to initialize an object with an unknown UUID. `XXX` for attribute: `files`. This can be the result of a merge and the unknown UUID is being discarded. 解决方式如下： 1.打开项目-&gt;Target-&gt;General-&gt;Linked Frameworks and Libraries，选中libpods-XXX.a，XXX是指你的项目名称，点“-”删除。 2.退出Xcode 3.重新执行pod install 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods中的Smart quotes were detected...警告]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F01%2FCocoaPods%E4%B8%AD%E7%9A%84Smart-quotes-were-detected-%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Tips在执行pod install命令时，出现了如下的警告：12345[!] Smart quotes were detected and ignored in your Podfile. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice. 大致的意思是：在Podfile文件中，引号被智能的检测到并被忽略。 通过检查Podfile文件，发现了如下代码： 1target 'Demo’ do 这明显是因为输入法切换导致的右引号写成了中文的单引号，这个问题很难被发现，即便没什么影响，但是改一下就可以消除警告，何乐为不为： 1target 'Demo' do 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIViewController继承时父子类方法重名造成的一个crash]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F31%2FUIViewController%E7%BB%A7%E6%89%BF%E6%97%B6%E7%88%B6%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%B8%AAcrash%2F</url>
    <content type="text"><![CDATA[前言最近在开发过程中，遇到了一个因为UIViewController继承时父子类方法重名造成的一个crash问题，本文是问题的原因分析和解决方法。 内容1.一个crash问题的分析有如下父子类，SubViewController继承于BaseViewController，父子类中均有-addConstraintsForSubviews这个重名的私有方法。 1234567891011121314151617181920212223//父类@implementation BaseViewController- (void)viewDidLoad&#123; [super viewDidLoad]; //添加子视图 [self base_lazyLoadSubviews]; //添加约束 [self addConstraintsForSubviews];&#125;@end//子类@implementation SubViewController- (void)viewDidLoad&#123; [super viewDidLoad]; //添加子视图 [self sub_lazyLoadSubviews]; //添加约束 [self addConstraintsForSubviews];&#125;@end 实际运行过程中，遇到了如下的crash： 12345678910Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;NSLayoutConstraint for &lt;UIImageView: 0x10bee7fa0; frame = (0 0; 0 0); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17023ba00&gt;&gt;: A multiplier of 0 or a nil second item together with a location for the first attribute creates an illegal constraint of a location equal to a constant. Location attributes must be specified in pairs.&apos; 上述的-addConstraintsForSubviews方法中有用到AutoLayout做自动布局，crash也是因为自动布局导致的。经过断点调试，也就是走了一遍ViewController的生命周期方法，分析出了这个crash的原因： 1.子类执行-viewDidLoad时，调用了[super viewDidLoad]，触发父类的-viewDidLoad。 2.父类的-viewDidLoad方法中实现了基础的UI加载和布局，也就是父类对应的-base_lazyLoadSubviews和-addConstraintsForSubviews这两个方法。 3.当父类执行这两个方法时，其实就已经有问题了，因为子类有同名的-addConstraintsForSubviews方法，导致父类的方法实现被子类覆盖了，此时父类会去调用子类的-addConstraintsForSubviews去布局。 4.子类此时还没有执行-sub_lazyLoadSubviews方法，也就是子类的视图控件还没有添加到父视图上，此时执行AutoLayout，就造成了crash。 2.解决方法在父类增加一些共有的UI组件，某些情况下可以简化开发，但其实更多的时候，并没有省却很多麻烦。个人建议还是不要在公有的父类中增加过多的UI特性，以免日后更多的不必要的麻烦，子类过多，已经足够引起你的重视了。当然如果只是项目中的基类，用作埋点或其他用途，那么增加其他的UI特性，更是不合适的了。下面只是基于上述问题，提出对应的解决方案。 2.1.规范命名这其实是算是一个命名不规范导致的问题，如果是父类私有的方法，还是增加前缀比较安全，所以最简单的解决方式就是改名：-base_addConstraintsForSubviews-sub_addConstraintsForSubviews 2.2.更加优雅的解决方式上一种方法其实并不是很好，因为可能遇到其他开发者继承于你的父类的问题，如果每次都要告知对方去注意这些问题，就很容易出问题了。这里提出一种参考系统的生命周期方法中回调父类的方式去解决这个问题。在父类中的头文件，声明子类容易覆写的同类型方法： 1234@interface BaseViewController : UIViewController- (void)lazyLoadSubviews NS_REQUIRES_SUPER;- (void)addConstraintsForSubviews NS_REQUIRES_SUPER;@end 方法声明过程中，使用了系统的宏NS_REQUIRES_SUPER来修饰，表示子类覆写该方法时，必须在方法内部调用super的这个方法，否则会有如下的警告（以系统的UITableViewCell的-prepareForReuse方法为例）： 这样即便子类使用者在不知情的情况下，覆写了父类的同名方法，也会有警告提示，只要执行了父类的同名方法，就可以避免上述的问题发生。 参考 iOS 修饰符~ NS_UNAVAILABLE、NS_REQUIRES_SUPER NS_REQUIRES_SUPER 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F30%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍了在Mac环境下，通过Hexo+Github搭建个人博客的完整操作流程，笔者参考了部分现有的文章，通过实践，排除了一些坑，并多次尝试后，整理出本文。 步骤1.安装Node.js通过Homebrew安装，会很便捷，但是事后遇到了重启终端，执行nvm命令，报-bash: npm: command not found错误，只好重头做起，在Node.js官网下载包安装，也很方便。5分钟 搭建免费个人博客一文中提到的，使用Homebrew安装Node.js的命令如下，请注意其中的注释： 12345$ brew install nvm$ mkdir ~/.nvm$ export NVM_DIR=~/.nvm$ . $(brew --prefix nvm)/nvm.sh$ nvm install 4 //这里是大坑，这个指定了安装的版本，截止到本文书写时，node的版本已经到8.x了 个人建议还是直接去官网下载包安装。 2.安装Git这个是提交之后的内容必备的，Mac自带了git，就不再赘述。 3.安装Hexo终端命令如下（Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时要在前面加上sudo，否则会因为权限问题报错）： 1$ sudo npm install -g hexo 4.初始化Hexo终端cd到自己选定的一个文件夹（之后所有的hexo相关的文件都将安装在文件夹中）的上一层级目录（选定的文件夹包含于该层级下），执行hexo init命令： 12$ cd /Users/...$ hexo init XXX //XXX是对应的自己建立的文件夹的名字，用于存放之后关于hexo的所有文件 cd到XXX文件夹下，安装npm： 12$ cd XXX$ npm install 5.测试hexo执行命令，开启hexo： 1$ hexo s 执行命令后，在浏览器中访问：http://localhost:4000/看到下面的页面，说明本地访问成功，hexo的初始化工作结束： 执行下面的命令可以停止测试。 1$ Ctrl+C 6.建立Github关联的仓库在github新建一个仓库，仓库名固定为github用户名.github.io。 例如笔者的就是：kukumaluCN.github.io 获取到仓库的地址和git地址，后面使用。 7.配置_config.yml文件在之前的XXX文件夹下，有_config.yml文件，该文件是hexo的配置信息，因为不同版本，该文件的信息会有变化，所以网上的很多教程都不太适用，需要自己综合参考修改，下面的是根据笔者当前的配置列出的示例。 需要修改的基本信息如下，如果有其他需要，可以参考官网Hexo配置自行修改（注意冒号后面必须有空格）： 123456789101112131415161718# Sitetitle: 霖溦之境 #Hexo 博客标题subtitle: 霖溦的个人博客 #博客副标题description: 霖溦的个人博客author: 霖溦 #作者名language: zh-Hans #中文# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://github.com/kukumaluCN/kukumaluCN.github.io #github仓库的地址root: /# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址branch: master 8.安装hexo-deployer-git自动部署发布工具执行命令： 1$ npm install hexo-deployer-git --save 9.发布hexo修改完上述配置后，可以再次hexo s执行一次测试，看看修改后的效果。没有问题就可以发布了。 在XXX文件夹下生成静态页面，执行： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 这是三个命令，clean是清理缓存，g就是generate生成静态文件，d是deploy也就是最终的部署。 具体的命令参考官网：Hexo指令 执行上述命令时，可能因为没有关联github提示输入github的用户名和密码（参考第10条，可能是deploy中repo的设置问题，改成ssh就不会遇到该提示了，前提是你的github绑定了ssh key）。 10.发布文章cd到XXX目录下，执行命令： 1$ hexo new "title" //title是要发布的文章的标题 title是要发布的文章的标题，具体规范参考Hexo指令中关于new的一项。 执行之后，会在/XXX/source/_posts路径下生成“title.md”文件，具体的书写就是标准的markdown语法了，可以自行使用习惯的md编辑器书写。 文章编辑完之后执行如下命令发布： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 期间遇到了如下错误： 123remote: Invalid username or password.fatal: Authentication failed for &apos;https://github.com/kukumaluCN/kukumaluCN.github.io.git/&apos;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html 本以为是SSH key的问题，结果发现设置过了，经过实验，发现是配置文件的问题： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: git#repo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址repo: git@github.com:kukumaluCN/kukumaluCN.github.io.git #改成ssh地址branch: master 11.更换主题Hexo的主题有很多，具体参考：Thems这里以maupassant主题为例：cd XXX到刚才的目录。执行如下命令： 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 再次修改配置文件_config.yml，将theme的值改为maupassant。编辑完之后执行如下命令发布： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 参考 5分钟 搭建免费个人博客 Mac上搭建基于GitHub的Hexo博客 如何搭建自己的博客 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/07/30/Hexo-Github搭建个人博客/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于霖溦之境]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F27%2F%E5%85%B3%E4%BA%8E%E9%9C%96%E6%BA%A6%E4%B9%8B%E5%A2%83%2F</url>
    <content type="text"><![CDATA[这里是霖溦的个人博客，从今天开始将在这里陆续更新博文，博文内容不限于iOS开发技术，也包含个人爱好的点滴。 写于 2018.7.27 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/07/27/关于霖溦之境/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>随笔</category>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
</search>
