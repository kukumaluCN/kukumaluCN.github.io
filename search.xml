<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018书单]]></title>
    <url>%2F%2Fblog%2F2018%2F12%2F30%2F2018%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言2018年，是不那么平凡的一年，发生了很多事，也经历了很多事。按照APP的统计，今年一共读了30本书，在读书上一共累积了363小时，这是前两年数量的总和。像往年一样，大部分阅读时间，依旧是在上下班的地铁上。大概是得益于阅读速度的提升，也可能是得益于今年年中，有那么一段不怎么加班的时光。想来，加班，真的是浪费生命的一件事吧，呵呵。数量的增加，对应的质量，的确会相对的降低。今年看了那么几本“烂书”……也是感慨，即便过程中觉察到了一本书不好，也总会想要坚持看完它，想知道那个故事的结局，想彻底了解它的缺陷。到底，不是书的问题，是作者的态度吧，如果作为读者也是这般虎头蛇尾，那个书中的世界，就彻底荒废了吧。 书单1.《时间的朋友2017》2018.1.2-2018.1.8评价：★★★☆☆ 一直对于这类知识服务有一种特别的感触，像是速食食品，能吃饱，也很有味道，但就是总觉得怪怪的，可能是因为吸收太快，总不是那么的踏实。平时只是敢去听那些不想去读却又好奇的书籍，这类书籍的音频解读，真的只适合读后再去听，不然真的很破坏“美感”。《时间的朋友2017》是《罗辑思维》他们家的跨年演讲系列之一，具有一定的时效性。之所以读这本书，也是出于好奇，某种程度上，它就像是安慰剂，给一些迷茫的人一盏灯，阅读体验很爽快，读后却又很空虚。也许，只是自己的修养还不够吧。 2.《神们自己》2018.1.10-2018.1.27评价：★★★★★阿西莫夫的科幻小说，一本关于平行宇宙的幻想作品。“面对愚昧，神们自己也缄口不言”，这是全书三部分的标题，也是核心。阿西莫夫用奇异的幻想视角，为读者展现了一种完全不同的外星文明和物种，他们来自一个拥有不同的物理法则的平行宇宙，感觉上，他们应该更加接近电磁生物。“愚昧”，贯穿全书，归根到底，它源于利益和贪婪。面对愚昧，最好的选择，或许还是缄口不言。 3.《奥菲利亚的影子剧院》2018.1.27评价：★★★★★一本薄薄的绘本，一个温暖的故事。说来有趣，大学时，写过一篇关于影子的短篇小说，当时找了很多关于影子的素材，其中一些，就源自这本绘本。作者米切尔恩德，最有名的作品，应该还是《永远讲不完的故事》，当年大刘还推荐过。每年都应该读一些童话，童话世界中的幻想，总是能出乎意料的精彩。 4.《DK探索 太空旅行》2018.2.18评价：★★★★☆过年期间带回去看的一本。DK系列都是那种大开本的科普书，很适合小孩子去培养兴趣。 5.《黑客与画家》2018.1.30-2018.3.10评价：★★★★☆这是一本信息量很大的书，涉及了作者在很多方面的思考，比如编程思想，以及创业的一些思考。书如其名，作者将编程和绘画类比，进行阐述。书中的“黑客”不是我们通常意义上的黑客，而是其原本含义，更加接近我们通常所理解的“极客”。书中阐述了作者关于优秀的软件设计的一些观点，读来很是受用。关于自学，一直以来，最大的感受就是：“先做再学，需求推进”，不然永远是零，用书中的话就是： 画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”这种情况对于第一线的程序员真是再熟悉不过了。 6.《东京一年》2018.3.18-2018.4.5评价：★★★☆☆这是蒋方舟的一本日记形式的随笔集，记录了作者在东京独自生活一年的诸多感触。中学时代就听过这个名字了，只是从未接触过她的作品。说实话刚开始没看清书名，看到封面的配色，还以为是关于“某东”的创业史……内容不做过多的的评价，个人很喜欢读这类第一人称视角的随笔集，因为真切，所以很有代入感。能更加深切的感受到那个角色的那些经历。所谓的角色扮演，大概就是这样吧。真的很羡慕，能有一年的时间，去日本这样的地方，独处，放空。 7.《伏羲密码》2017.11.19-2018.4.15评价：★☆☆☆☆一本因为名字和简介被骗进来的书……本以为会是关于上古神话的幻想类小说，结果……这是一本前言内容比正文更加精彩的书，讲述了作者的大学时光以及创业历程，以及偶然的机会出版这本大学时写的烂尾作的经历。作者大概是想用一个科幻的视角，去阐述上古时代的伏羲神话，而且用了盗墓文学的展开。可惜全书挖坑不断，直到结尾也没有收住，彻底的坑了。前半部分的节奏还好，后面的就崩的不要不要的了，只能匆匆结尾。最关键的是，这本书今年还出了续作…… 8.《遗落的南境1：湮灭》2018.4.8-2018.4.21评价：★★★☆☆这本是科幻电影《湮灭》的原著。电影给人最大的观感就是阴森诡谲，很多地方都看不大懂，结局更是令人细思极恐。其实原著更甚。电影相对原著做了一定的改编，去掉了书中比较重要的几个设定。说实话个人不是很适应这类作品的观感，阅读体验很不舒适。提到这部就不得不说其在星云奖的角逐中胜了《三体》。个人感觉，这两部作品没有太多可比性，不能算是同类型的作品，《三体》注重的的硬科幻设定，《湮灭》更多的是人性心理描写和气氛渲染，科幻内核较软。个人比较喜欢大刘的幻想世界，他在架构一个世界时，会用一个很贴近我们身边现实的人物角色，带着我们一起，去探索和经历那个世界。而这部，相对来说各种环境都是陌生的，主角的内心世界亦是如此。一个幻想世界，没有引路人，读者冒然进入其中，会感到独孤，甚至是恐惧。或许在某种意义上，这也是一种优势吧。 9.《半小时漫画中国史》2018.4.28-2018.5.5评价：★★★★☆一本浅显易懂的春秋战国史，作者以漫画的形式来展现那段历史的混乱，很生动，一些角色设定真的很形象。这类入门读物，很适合初学者，或者是想理清历史脉络的人去读。就像作者在介绍中说的，只是想为大家提供一个历史框架，至于读者对哪段历史有了兴趣，想进一步研究，作者的目的其实已经达到了。 10.《半小时漫画世界史》2018.5.5-2018.5.11评价：★★★☆☆作者一贯的极简风格，不过这本的内容比较宽泛零散。书中涉及了世界史中的一些大事件。了解世界史还是有用的，至少在读外国文学作品时，了解对应的历史背景，更有助于理解其内涵，不然就只是流于故事表面了。 11.《天意》2018.5.14-2018.5.23评价：★★★★★国产历史科幻小说，中国科幻“银河奖”获奖作品。作者对于华夏文明的起源，开了一个巨大的脑洞，并用科幻的角度，在尊重史实的基础上，重构了楚汉之争那段历史。因为作者身为历史老师的缘故，书中对于历史人物的刻画，十分生动，而且女性的细腻笔触，在国内科幻作品中占有绝对优势。 12.《那颗星星不在星图上：寻找太阳系的疆界》2018.5.23-2018.6.1评价：★★★★★一本关于太阳系各大行星探索和发现的科学史向的科普作品。作者卢昌海先生，是一位十分有智有趣的人，他的科普作品，文如其人，科普能写出小说情节般的跌宕感。当然作者的科学素养是不容置疑的，也只有学识深厚的人，才能把科学史写的如此通俗生动。 13.《我的“微言小义”》2018.6.1-2018.6.16评价：★★★★☆这是科普作家卢昌海先生将个人微博中的精华部分整理成册，出版的一本随笔集。书中涉及了作者对于生活、读书、观影、科普等诸多方面的思考和感想，足见作者的生活情趣。也因此，买了作者已经出版的所有书籍，以备阅读。 14.《东野圭吾的最后致意》2018.6.19-2018.7.1评价：★★★★☆大概是养成了一个习惯，读某位作者的作品之前，必然要先了解下这个人，如果有自传，就必定要先读一下。卢昌海先生在个人随笔集中表达了自己对于东野圭吾作品的喜爱之情。东野圭吾，其实并不陌生，各大出版物媒体平台的明星人物，然而一直都没看过他的书，这是第一本。在这本自传中，东野圭吾自述为一个有趣却也无趣的人，他拥有和我们大多数人差不多的学生时代。工科出身的他，第一份工作和写作没有任何关系。他写作就是为了摆脱生活现状，说白了就是为了生存而写，当然兴趣也是前提。通读全书，发现东野圭吾除了是一个目的性极强的人，也是一个极其自律的人，表现在它每天极为规律的作息，以及相对较高的产出。大概就是因为严苛，才能产出严谨的推理作品吧。 15.《三体世界》2018.6.9-2018.7.1评价：★★★☆☆这绝对是一本被低估了的书，一本被书名和出版方毁掉了的相对较好的国产科幻作品。大概是因为它出版那年，大刘的《三体》还没有那么大的影响力，《三体世界》无论从书名还是宣传标语，甚至是书中的某些科幻设定，都在一定程度上，蹭了《三体》的热度，《三体》大火之后，这本书毫无意外的，被打上了山寨的标签……发现这本书完全是意外，大刘的《三体》在国际上获奖，在国内引起轰动之前，还只是科幻圈内的宠儿。那时在买书的时候，意外的发现了这本《三体世界》，本以为这是一本同人作，就像宝树的那本《三体X》一样，出于爱屋及乌的心态，一并买来留存。那天出于好奇，翻开来读，情节居然意外的吸引人。在豆瓣上看了下评价，大都的是针对其山寨行径的无情差评。摒弃这些，耐下心看完这本书之后，还是有些感慨的。这本书的科幻内核还是比较硬的，作者在太阳系维度，构建了一个三体世界，三星系统中包括太阳、太阳伴星复仇女神星（这个概念不是作者原创的）、以及一个类似人造虫洞的天体。作者通篇运用了大量的量子力学和弦理论的作为故事情节的主要设定。本书在人设上，有网络文学的痕迹，比较严重的后宫倾向主角团。悬疑设定过于简单粗暴，但是好在足够吸引人。对于量子力学和弦论的引用比较生硬，基本是大段的科普，没有较为生动的转述，阅读门槛较高。全书至关重要的“希望之桥”的设定，和《三体》中的二向箔类似，原理都是真空衰变，只是在情节中的作用不同，不能算是撞梗。这本书的结局是出人意料的，构造了一个死亡循环的死局，比较出彩。如果这本书作为同人作的话，部分情节稍微润色下，绝对是优秀作品了，至少在国内科幻，算是中上水平的。有时候，出版社的决策，直接决定了一本书的生死。 16.《果壳里的一百五十九个宇宙》2018.7.1-2018.7.15评价：★★☆☆☆网红科学家李淼先生的科幻脑洞随笔集，全书由159个短篇脑洞随笔组成。其中有几篇写的很有意思，但是大部分的都较为平庸。想看科学家如何做科幻设定，那些优秀篇目还是很有参考价值的。 17.《我的晃荡的青春》2018.7.15-2018.7.23评价：★★★★☆东野圭吾的青春回忆录，这本是其在《东野圭吾的最后致意》中反复被提及的作品。通篇讲述了作者学生时代作为“学渣”的各种有趣的经历，很有意思。一个人的经历，在其日后的作品中，多多少少的都会有着那些身影吧。 18.《借东西的小人》2018.7.23-2018.7.27评价：★★★★☆吉卜力同名动画的原著，一直都还没有看过这部动画，恰好看到了这本书。作为童话故事，这本书讽刺了很多现实。小孩子总是能看到一些我们看不到的有趣事物吧？想来也是可悲，虽然我们年龄增长了，认知能力提升了，却越来越不能接受那些超出我们所谓常识常理的事物了。那被我们视为珍宝的想象力，有的时候，却也因某些莫名的恐惧而被我们抗拒着。人大抵是趋于安稳的吧，这种趋势源于我们的惰性，这种平衡不允许被任何意外打破，即便那曾是我们向往的、期待的，不平凡。 19.《与罗摩相会》2018.7.26-2018.8.7评价：★★★★★一部令人敬畏的科幻神作！这本书早年被翻译为《与拉玛相会》。大刘很喜欢阿瑟克拉克的作品，曾谦逊的表示自己的作品是对其拙劣的模仿。看过阿瑟克拉克的作品就会了解到一些原因，阿瑟克拉克的作品充斥着严谨的硬科幻设定，以及大量的技术细节。大刘的作品也有类似的特质。这本书讲述了人类探索一艘意外闯入太阳系的外星飞船的过程。直至全书结束，也没有出现过外星人，最后外星飞船“意外”的飞离太阳系，人类由恐慌变成了失望，一种因被外星超级文明的忽视的恼怒和失望。在超级文明面前，人类并不值得被接触。探索“罗摩”的过程，很像是一次针对失落的文明的古墓探险，或是神庙朝圣，面对未知的神迹，人类试图的探索，总会和宗教朝圣相类似。或许留白，才是对外星文明最准确的描述，因为那种文明绝对超乎我们一切的想象力所能及。 20.《山茶文具店》2018.8.7-2018.8.20评价：★★★★★年度暖心之作！日本镰仓真的是一个令人向往的地方啊。书中的主角内心戏丰富，很有意思，她总能以一个有趣的视角看待人和事，给各种人根据其特点起外号。她身边的人也都很有意思。然而她的童年却并不美好。人生总会充满了缺憾，有时，只是因为我们不会去爱吧。代笔人，是怎样的一种体验呢？鳗鱼饭，真的很好吃吧。 21.《十二个明天》2018.8.25-2018.10.11评价：★★☆☆☆一部作者阵容豪华的短篇小说集，开篇就是大刘的新作《黄金原野》。然而，不知道是不是翻译的问题，除了包括《黄金原野》在内的几篇作品，其他的，可读性都很差。耐着性子读下去的，不过还是有一篇实在看不下去，因为没看懂…… 22.《韭菜的自我修养》2018.9.21-2018.10.12评价：★★★☆☆李笑来的一本小册子，关于这本书出版的目的不做任何评论。单从理财角度看，对于新手来说，应该还是有一些借鉴意义的。 23.《给忙碌者的天体物理学》2018.7.2-2018.11.15评价：★★★★☆一本关于当代天体物理学前言理论的简介的科普读物。一本装帧横精美的小册子，很方便随身携带翻阅。断断续续的看了一阵子，后来又重头开始一口气看完了，内容很精彩。对于想要了解当代天体物理学所描述的宇宙简史的人，是一本不错的入门读物。内容形式上很像《七堂极简物理课》。 24.《猎户座防线》2018.11.12-2018.11.15评价：★★★★☆《Xeelee》中的一部短篇科幻作品。硬科幻的典型代表之作。因为国内并没有引进，网上只能看到《猎户座防线》这部分的翻译内容。改变物理常数，会发生什么？以物理法则为武器，如何发动战争？相对于直接使用物理法则作为武器的光粒或者二向箔，改变物理法则，真的更可怕。 25.《古蜀》2018.11.4-2018.11.20评价：★★☆☆☆王晋康老师的一本神话幻想小说。作为中国科幻四天王之一，王晋康老师的作品，我还是第一次接触。偶然看到了这本书，因为对神话题材很感兴趣，又因为涉及了古蜀国文明，就很有开心的入坑了……作为一位科幻作家，在这本书中，作者的表述方式总给人一种掉书袋的感觉，各种生僻字生僻词汇。而且神话幻想方面也很俗套，毫无惊艳之处。本书作为一本面向青少年的幻想类作品，其实内容并不是那么的合格。很多性暗示的情节，处理的很不恰当，即便上古先民对这些还没有过多的礼仪限制，但是浪漫的手法总应该是要有的。 26.《程序员的爱情》2018.5.5-2018.11.23评价：★☆☆☆☆一本让我很无语的书……本来是特意找来做为参考的，可惜这本书简直就是灾难……可以看得出，作者应该是程序员出身，因为一些工作场景的描述的确很程序员，没有经历过的人，大概很难描绘，个人作为程序员，还是深有感触的。但是在爱情描写方面，不是作者笔力不够，就是作者的爱情观有问题。这部作品的感情线，就是集车祸、出轨、包养、特殊身世等一堆烂梗于一身的无聊透顶的堆叠。看完这本书，大概很多人不会再相信爱情了吧……作者在故事情节整体的把控能力上表现的很差，中段的情节有明显的拼凑堆叠的嫌疑，很多描写也不明所以，后期节奏加快，也就是最灾难的部分，各种意外，各种反转……最奇葩的，就是结局采用了留白的方式，不知道是不是作者已经无力结束这一切，总之书中那可怜的男主，渣的境界得到了终极升华……几度弃书，终是耐着足够的性子读完了，大概是想引以为戒吧。 27.《写给大人的睡前故事》2018.5.5-2018.11.23评价：★★★★☆一本很有意思的短篇小说集，其中有几篇的构思还是很精巧的。睡前读的确会很适合，可惜我是早上读的。 28.《龙猫的肚子为什么软绵绵》2018.4.23-2018.12.21评价：★★★★☆每年都想读一本关于宫崎骏或者吉卜力的作品，因为实在有很多东西值得发掘和思考。这是一本信息量比较大的书籍，作者在吉卜力师从铃木敏夫，收获了很多很有意思的关于创作的见解。从某种意义上来讲，铃木敏夫成就了宫崎骏。想来，吉卜力的电影之所以耐看，还真的是因为信息量大的问题，真人电影的信息量看似更大，但是动画是以抽象化的角度重构的信息，更加容易令人接受，这样有效的信息量就会相对高很多，吉卜力的动画的特色和制作技法，在诸多动画作品中，无疑具有更大的信息量。 29.《看见》2017.2.12-2018.12.23评价：★★★★★其实这本书的阅读跨度长达两年之久，之所以会这样，是因为这本书每个章节的篇幅很长，信息量也很大，不是很喜欢用碎片化的时间去读这类作品，只能等到没什么事的周末，找一个下午或者一整天来读。柴静的文字就像她的性格，简洁、锋利，单刀直入，无所顾忌，直戳人心。我不会更多的去评价她这个人，也无法直接评价这本书。这本书所记录的，是这个时代的一些缩影，并不能读一遍就消化的掉，而且因为个人阅历的限制，很多东西，还不能深刻的去理解。以后找时间，还是要再读一遍才好。 30.《催眠师手记2》2018.4.24-2018.12.29评价：★★★★★个人很喜欢高铭的作品，有脑洞，也有思考。大学时代看完了这本书的第一季，第二季一出来，第一时间就买来看了。这一季的故事还是很精彩的，很贴近当下的现实。很多时候，梦境，真的反映了太多的东西，只是我们没有觉察到，或是觉察到了没有明白。在这个社会中，我们多多少少都会有一些心理上的问题，如果能有机会接受一些科学的心理治疗或是调节，可能会更加利于身心健康吧。所以，《时间线》系列是要出单行本吗？ 结语以上，就是今年的修行了，明年继续~今年还在得到APP和喜马拉雅APP上听了75本书，只能算是囫囵的了解了一些大概的点，想要有所得，大概还是要细细去读才好。 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/12/30/2018书单/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>总结</category>
        <category>2018</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于转场动画中“Unbalanced calls to begin/end appearance transitions for \”警告的解决]]></title>
    <url>%2F%2Fblog%2F2018%2F12%2F05%2F%E5%85%B3%E4%BA%8E%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E4%B8%AD%E2%80%9CUnbalanced-calls-to-begin-end-appearance-transitions-for-UIViewController-%E2%80%9D%E8%AD%A6%E5%91%8A%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Tips最近学习转场动画时，参考了喵神的这篇文章：WWDC 2013 Session笔记 - iOS7中的ViewController切换，文中有这样一段示例代码： 12345678910111213141516//ContainerVC.m[self addChildViewController:toVC];[fromVC willMoveToParentViewController:nil];[self.view addSubview:toVC.view];__weak id weakSelf = self;[self transitionFromViewController:fromVC toViewController:toVC duration:0.3 options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123;&#125; completion:^(BOOL finished) &#123; [fromVC.view removeFromSuperView]; [fromVC removeFromParentViewController]; [toVC didMoveToParentViewController:weakSelf];&#125;]; 是iOS7以前的转场动画的实现方案，实验这段代码时，控制台报了如下警告： 1Unbalanced calls to begin/end appearance transitions for &lt;UIViewController: 0x7fc28fc1c080&gt;. 通过查找原因，解决方案如下： 1234567891011121314//ContainerVC.m[self addChildViewController:toVC];[fromVC willMoveToParentViewController:nil];__weak id weakSelf = self;[self transitionFromViewController:fromVC toViewController:toVC duration:0.3 options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123;&#125; completion:^(BOOL finished) &#123; [fromVC removeFromParentViewController]; [toVC didMoveToParentViewController:weakSelf];&#125;]; 只是去掉了关于vc.view的操作，解释在这里：Unbalanced calls to begin/end appearance transitions for \&lt;UIViewController> Turns out transitionFromViewController:toViewController:duration:options:animations:completion: also adds the view. This method adds the second view controller’s view to the view hierarchy and then performs the animations defined in your animations block. After the animation completes, it removes the first view controller’s view from the view hierarchy.Which means the addSubview needs to be adjusted accordingly. 也就是说transitionFromViewController:toViewController:duration:options:animations:completion:这个方法内部已经做了关于vc.view的管理，我们不需要再自行添加和移除对应的view了。 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/12/05/关于转场动画中“Unbalanced-calls-to-begin-end-appearance-transitions-for-UIViewController-”警告的解决/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>转场动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种字符串关键字检索高亮的简易实现]]></title>
    <url>%2F%2Fblog%2F2018%2F11%2F22%2F%E4%B8%80%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%B3%E9%94%AE%E5%AD%97%E6%A3%80%E7%B4%A2%E9%AB%98%E4%BA%AE%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 本文Demo地址：Demo，喜欢请star我的Demo集合：JXT_iOS_Demos，喜欢请star 平时开发中，我们总会不时的和富文本打交道。有时，我们需要用富文本高亮某句话中的某个关键字，如果这个关键字只出现一次，或者说这句话比较短，用- (NSRange)rangeOfString:(NSString *)searchString这个方法就可以很容易的确定这些关键字的range，如果是固定的一句话，那甚至可以将range写成固定值。但是如果是一篇文章，就会相对棘手些。这个问题其实很像是关键字检索高亮的问题，网上有很多相关的算法甚至三方库，比如ICTextView，下面提供一个十分简单的基于系统API的方法来解决这个问题，效果如下： Code其实这个算法的核心就在于如何同时获取到字符串中重复出现的所有的子串的range，- (NSRange)rangeOfString:(NSString *)searchString方法只能获取到第一次出现的子串的range，设置NSStringCompareOptions，可以改变获取到的结果，但是也只能获取到一个，不知道系统有没有提供直接的方法，笔者暂时是没有发现……简单的算法就是遍历，网上也有很多人提供了代码，但大部分都是多次遍历，效率肯定不会太好，经过调试和优化，笔者有了如下方法，通过几万字的字符串匹配验证，依旧可以保持在毫秒级，应该是可以适用于大部分简单的场景了，主要是算法相对于正则或者其他方式，简单易懂： 12345678910111213141516171819202122232425- (void)jxt_enumerateRangeOfString:(NSString *)searchString usingBlock:(void (^)(NSRange searchStringRange, NSUInteger idx, BOOL *stop))block&#123; if ([self isKindOfClass:[NSString class]] &amp;&amp; self.length &amp;&amp; [searchString isKindOfClass:[NSString class]] &amp;&amp; searchString.length) &#123; NSArray &lt;NSString *&gt;*separatedArray = [self componentsSeparatedByString:searchString]; if (separatedArray.count &lt; 2) &#123; return ; &#125; NSUInteger count = separatedArray.count - 1; //少遍历一次，因为拆分之后，最后一部分是没用的 NSUInteger length = searchString.length; __block NSUInteger location = 0; [separatedArray enumerateObjectsUsingBlock:^(NSString * _Nonnull componentString, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (idx == count) &#123; *stop = YES; &#125; else &#123; location += componentString.length; //跳过待筛选串前面的串长度 if (block) &#123; block(NSMakeRange(location, length), idx, stop); &#125; location += length; //跳过待筛选串的长度 &#125; &#125;]; &#125;&#125; 具体使用如下： 123456[attributedString.string jxt_enumerateRangeOfString:searchString usingBlock:^(NSRange searchStringRange, NSUInteger idx, BOOL *stop) &#123; [attributedString addAttributes:@&#123; NSForegroundColorAttributeName:[UIColor redColor], NSBackgroundColorAttributeName:[[UIColor blueColor] colorWithAlphaComponent:0.2], &#125; range:searchStringRange];&#125;]; 本文作者： 霖溦本文链接： https://kukumalucn.github.io/blog/2018/11/22/一种字符串关键字检索高亮的简易实现/版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSString</tag>
        <tag>关键字</tag>
        <tag>检索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于performSelector的一点注意]]></title>
    <url>%2F%2Fblog%2F2018%2F11%2F16%2F%E5%85%B3%E4%BA%8EperformSelector%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[前言刚在群里看到这样一段代码，很有意思： 123456789101112- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"1"); [self performSelector:@selector(test) withObject:nil afterDelay:0]; NSLog(@"2"); &#125;);&#125;- (void)test&#123; NSLog(@"3");&#125; 这段代码的执行结果会是什么呢？是打印“1、2”，还是“1、3、2”，或者是“1、2、3”？ 内容1.问题探究这其实是一道很有意思的面试题，内容涉及runloop这个知识点。答案是只打印：“1、2”。原因群里的大神给了解答： 因为[self performSelector:@selector(test) withObject:nil afterDelay:.0]实际在runloop里面，是一个定时器，但是因为在子线程，runloop是默认没有开启的。 这除了涉及runloop，还有多线程的问题，有兴趣的可以深究。其实我们只要仔细阅读苹果API的注释，就能解释这个问题： 想要执行-test方法，注释里也提供了解决办法： 1[self performSelectorOnMainThread:@selector(test) withObject:nil waitUntilDone:YES]; 其实针对上述的逻辑，更简单的是： 1[self performSelector:@selector(test) withObject:nil]; 2.引发的思考2.1.不要懒之所以要提上述的问题，除了这个面试的“考点”，其实在平时的开发过程中也要注意自己代码的严谨性。我发现自己在阅读别人的代码时，就见过同样的写法，其实甚至那些比较有名的三方库，例如“YYText”中，也有类似的代码存在： 1[self performSelector:@selector(test) withObject:nil afterDelay:0]; 写这段代码的人只是为了通过selector来立刻执行某一方法，delay并不是他们的需求，为什么还要“多此一举”呢？这里一大部分原因，很可能还是因为我们被xcode的自动提示给“惯坏了”： 毕竟当你写代码时，罗列的一堆提示，只是按照API相似度排列出来的，很多人看到了自己需要的就直接回车了，不需要delay，直接写0，就行了，反正“都一样”……其实这是一个误区，看起来很相似的API，实则并不一样，而且很不一样： 我们常用的这个perform，是NSObject.h这个头文件下的方法： 可以delay的，是NSRunLoop.h下的方法： 而之前提到的回调主线程的，是NSThread.h里的方法： 虽然他们都是NSObject的方法或者是分类补充方法，但实际上，是隶属于不同的模块的。 2.2.更深刻的原因但是“YYText”的作者应该是不会犯这种低级错误的，那就应该还有更深刻的原因了： 我们很多人应该总是会被上述的警告所困扰，大多数人的解决方式，就是利用类似相面的方式去屏蔽警告，这种做法虽然简单，但实际是有风险的： 1234#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks"//code#pragma clang diagnostic pop 其实除了利用IMP或者NSInvocation那种比较“高端”的方式，更多的情况下，在方法没有返回值时，或者我们不需要返回值时，我们可以用： 1[self performSelector:@selector(test) withObject:nil afterDelay:0]; 这种方式去避免警告的，看上面的那三个对比你就会发现，后两类API，同样是performSelector，却没有返回值，这其实也是有官方注释的依据的： 但其实你也要注意到了，官方的建议还是很严谨的，是用performSelectorOnMainThread，而不是delay0的方式，至于原因，我们又回到了文章一开头的讨论了。 总结通过上面看似无意义的探究，我们还是可以得到很深刻的教训的：“苹果霸霸”还是很严谨的，多看API的注释，总是没错的。 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/11/16/关于performSelector的一点注意/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>performSelector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods的版本升级和降级]]></title>
    <url>%2F%2Fblog%2F2018%2F09%2F20%2FCocoapods%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Tips在平时开发中，有时可能会遇到Cocoapods的版本的问题，我们实际使用的版本可能会因为过低而导致各种问题，这时需要升级，有时又会因为某个开源库不支持最新的Cocoapods版本而不得不降级我们本地的Cocoapods。 1.升级 升级比较简单，实际命令如下： 1$ sudo gem install -n /usr/local/bin cocoapods -v 1.5.3 -v后面是版本号，当前Cocoapods的release版为1.5.3。输入密码之后即可执行升级操作。升级结束后，可以查看下当前的pod版本: 1234//执行命令查看版本信息$ pod --version//输出的版本号是最新的1.5.3 2.切换Ruby源 执行上述命令时，可能会遇到如下的错误： 12ERROR: Could not find a valid gem 'cocoapods' (= 1.5.3), here is why: Unable to download data from https://gems.ruby-china.org/ - bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz) 这是因为之前在配置Cocoapods时，本地的源设置的问题，这篇文章写下时，RubyGems的国内镜像已经变成了：https://gems.ruby-china.com。我们需要手动切换一下： 123456//查询本地源的列表$ gem sources -l//删除已经不能使用的源$ gem sources --remove https://gems.ruby-china.org///添加最新的源$ gem sources -a https://gems.ruby-china.com 123456//再次查询$ gem sources -l//可以看下如下信息，表示切换成功：*** CURRENT SOURCES ***https://gems.ruby-china.com 3.降级 和执行升级操作一样，比如想要安装1.5.0版本，执行如下命令： 1$ sudo gem install -n /usr/local/bin cocoapods -v 1.5.0 提示安装成功后，再次查询版本号： 1234//执行命令查看版本信息$ pod --version//输出的版本号依旧是最新的1.5.3 这是因为本地安装了多个版本的cocoapods，默认使用最新的版本，想要切换低版本，可以执行如下操作： 123456789101112131415161718192021//执行卸载命令$ sudo gem uninstall cocoapods//提示卸载哪一版本，并列出本地安装过的所有版本Select gem to uninstall: 1. cocoapods-1.1.1 2. cocoapods-1.2.1 3. cocoapods-1.3.1 4. cocoapods-1.5.0 5. cocoapods-1.5.3 6. All versions//输入5，卸载最新的那一版本&gt; 5//提示卸载成功Successfully uninstalled cocoapods-1.5.3//查询版本号，可以看到此时使用的是1.5.0，也就是当前最新的版本了$ pod --version1.5.0 除了上述的方法，还可以: 12345678//列出所有信息$ gem list//找到此项cocoapods (1.1.1, 1.2.1, 1.3.1, 1.5.0, 1.5.3)//移除指定版本cocoapods$ sudo gem uninstall cocoapods -v 1.5.3 参考 安装CocoaPods 出现这样的问题 升级 Cocoapods 到1.2.0指定版本，降低版本及卸载 iOS开发中如何管理多个版本的Cocoapods、gem cocoapods 卸载,重装,高版本的使用 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/09/20/Cocoapods的版本升级和降级/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机内容字符串]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F13%2F%E9%9A%8F%E6%9C%BA%E5%86%85%E5%AE%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前言我们再平时开发过程中，可能需要一些随机内容的字符串用于测试，例如：任意长度的内容字符串，测试我们的tableView的cell的高度自适应，这类测试有利于发现一些隐藏的bug。 正文1.随机长度的字符串比较简单的做法是，有一个固定的字符串，我们去取其随机长度的子串。 12NSString *str = @&quot;测试字符串&quot;;NSString *randomStr = [str substringToIndex:arc4random_uniform((uint32_t)(str.length))]; 2.利用CCRandomGenerateBytes生成随机字符串这个方法参考这里：ios CCRandomGenerateBytes 生成定长随机字符串可以生成任意长度的，随机的字母和数字组合的字符串，他本质是用作生成随机密钥的。 12345678910111213141516171819202122232425//利用CCRandomGenerateBytes生成随机字符串+ (NSString *)jxt_randomStringWithLength:(size_t)length&#123; if (length &lt; 1) &#123; return nil; &#125; length = length*0.5; unsigned char digest[length]; CCRNGStatus status = CCRandomGenerateBytes(digest, length); if (status == kCCSuccess) &#123; return [self private_jxt_stringFrom:digest length:length]; &#125; return nil;&#125;//将bytes转为字符串+ (NSString *)private_jxt_stringFrom:(unsigned char *)digest length:(size_t)length&#123; NSMutableString *string = [NSMutableString string]; for (int i = 0; i &lt; length; i++) &#123; [string appendFormat:@&quot;%02x&quot;,digest[i]]; &#125; return string;&#125; 3.指定位数随机数的生成这个一般用于验证码等随机密码的业务场合，常用的是生成4位或6位的随机数组合： 1234//6位随机数[NSString stringWithFormat:@&quot;%06d&quot;, arc4random() % 1000000];//4位随机数[NSString stringWithFormat:@&quot;%04d&quot;, arc4random() % 10000]; 上述的算法比较简单，但是当我们需要长度更大的随机数字时，这个算法就有局限了，因为arc4random()的取值范围是0～4294967295，针对这个问题，我们可以改进一下： 12345678+ (NSString *)jxt_randomDigitsStringWithLength:(NSUInteger)length&#123; NSString *randomDigits = @&quot;&quot;; for (int i = 0; i &lt; length; i ++) &#123; randomDigits = [randomDigits stringByAppendingFormat:@&quot;%d&quot;, (arc4random() % 10)]; &#125; return randomDigits;&#125; 当然上述算法在性能上是比不上先前的两个的，所以要根据需求取舍。 Demo详见：RandomStringForTest 参考ios CCRandomGenerateBytes 生成定长随机字符串 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/13/随机内容字符串/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用结构体初始化大量布局常数]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F09%2F%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E9%87%8F%E5%B8%83%E5%B1%80%E5%B8%B8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言在平时UI适配开发中，可能会用到Masonry或者手写布局，在这些布局中，经常会用到一些常量，例如： 123456- (void)addSubviewsConstraints [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.top.mas_equalTo(self.view).offset(10); make.width.height.mas_equalTo(100); &#125;];&#125; 或者： 12345- (void)layoutSubviews&#123; [super layoutSubviews]; self.myView.frame = CGRectMake(10, 10, 100, 100);&#125; 上面只是两个固定值的例子，在Masonry中，offset(10)是一个间距值，对应手写frame布局就是origin.x和origin.y，这些值很可能是一些常数，一般不会更改，不过，如果肆意任这些常数散落在代码中，对于后期维护，可能会带来不小的麻烦。 内容1.一般做法针对上述的麻烦，一般的做法是，布局时，统一初始化一些常数，后期维护，只是更改这些常数就好了。例如： 12345678910111213141516171819//布局常数CGFloat myViewLeftGap = 10, myViewTopGap = 10;CGSize myViewSize = CGSizeMake(100, 100);//Masonry- (void)addSubviewsConstraints [self.myView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.mas_equalTo(self.view).offset(myViewLeftGap); make.top.mas_equalTo(self.view).offset(myViewTopGap); make.size.mas_equalTo(myViewSize); &#125;];&#125;//frame- (void)layoutSubviews&#123; [super layoutSubviews]; self.myView.frame = CGRectMake(myViewLeftGap, myViewTopGap, myViewSize.width, myViewSize.height); //或者 self.myView.frame = (CGRect)&#123;myViewLeftGap, myViewTopGap, myViewSize&#125;;&#125; 这样做看似麻烦，但是后期改起来，或者是调试bug时，我们只要关心常量的初始化部分就好了，不用再去看对应的布局代码，这就很省心了。 2.使用结构体统一管理的优化上面的做法相对已经好了很多，但是，对于复杂的页面，页面的视图元素比较多时，这种方法会显得很臃肿，你要在布局代码前，初始化大量的常量，这种做法很不好，而且，在系统执行布局刷新时，对应的常数，再次被初始化了一遍，即便值没有更改，这就造成了不必要的开销。对于这个问题，我们这里引入了结构体，结构体在iOS开发中，一般会很少使用，但其实系统中有很多例子，之前提到的CGRect和CGSize都是结构体这种数据结构。下面是利用结构体对之前的做法的一种优化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 声明布局常量结构体 */typedef struct &#123; CGFloat myViewLeftGap; CGFloat myViewTopGap; CGSize myViewSize;&#125; MyLayoutConsts;@interface ViewController ()@property (nonatomic, strong) UIView * myView;@end@implementation ViewController&#123; MyLayoutConsts _layout; //结构体全局变量&#125;#pragma mark - Life Cycle- (void)viewDidLoad&#123; [super viewDidLoad]; //初始化结构体，结构体的初始化有很多种方式，我采用的这种，会显得比较清晰，便于修改 _layout = (MyLayoutConsts)&#123; .myViewLeftGap = 20, .myViewTopGap = 20, .myViewSize = CGSizeMake(100, 100) &#125;; [self.view addSubview:self.myView];&#125;#pragma mark - UI- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; self.myView.frame = (CGRect)&#123;_layout.myViewLeftGap, _layout.myViewTopGap, _layout.myViewSize&#125;;&#125;#pragma mark - Lazy Load- (UIView *)myView&#123; if (!_myView) &#123; _myView = [[UIView alloc] initWithFrame:CGRectZero]; _myView.backgroundColor = [UIColor redColor]; &#125; return _myView;&#125;@end 这里使用MyLayoutConsts _layout;而没有使用属性，是为了节省调用get方法的开销，本质是一样的。当然，这里要注意，_layout.myViewLeftGap语句本质上是selg-&gt;_layout.myViewLeftGap，所以要注意在block中的循环引用的问题。 Demo详见StructForLayoutDemo 参考 iOS开发中结构体的另一种“初始化方法” 结构体的4种初始化方式 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/09/用结构体初始化大量布局常数/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一台电脑管理多个Git账户和SSH KEY]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F02%2F%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAGit%E8%B4%A6%E6%88%B7%E5%92%8CSSH-KEY%2F</url>
    <content type="text"><![CDATA[前言平时开发过程中可能遇到这样的问题，就是在进行公司的项目开发时要用公司的git账号，以及对应的git仓库，比如gitlab的；对于个人的开源项目，又会有自己的git账号，以及对应的git仓库，比如github或者码云（gitee）。这时就会遇到多账户提交时的冲突问题，以及对应的多个ssh key的管理的问题。 正文1.多个ssh key的管理1.1.ssh key的创建假如有两个git账户，分别是`github@example.com和gitee@example.com`。为了提交git，我们需要设置对应的ssh key，ssh key具体其在对应平台的配置方法比较简单，本文不再详述，可参考对应的资料，这里只是ssh key的创建及管理。在终端输入如下命令： 1$ ssh-keygen -t rsa -C "github@example.com" 终端提示如下： 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): 此时直接回车，就会在/Users/XXX/.ssh/路径下，创建一个名为id_rsa的公钥，这个并不是我们想要的，因为这里要设计多个ssh key的管理，这个命名没有任何特征。 在终端中输入如下命令： 1$ /Users/XXX/.ssh/id_rsa_github 表示这个是github平台的key，之后根据终端提示，输入并确认密码，就可以生成了。 123456Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/XXX/.ssh/id_rsa_github.Your public key has been saved in /Users/XXX/.ssh/id_rsa_github.pub.The key fingerprint is:... 同理，另一个ssh key的创建流程如下： 12345678910$ ssh-keygen -t rsa -C "gitee@example.com"Generating public/private rsa key pair.Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): $ /Users/XXX/.ssh/id_rsa_giteeEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/XXX/.ssh/id_rsa_gitee.Your public key has been saved in /Users/XXX/.ssh/id_rsa_gitee.pub.The key fingerprint is:... 1.2.配置ssh代理创建好了上面的多个ssh key就可以开始管理他们了。在终端中输入如下命令，查询系统ssh key的代理： 1$ ssh-add -l 如果系统已经设置了代理，需要删除： 12$ ssh-add -DAll identities removed. 如果提示： 1Could not open a connection to your authentication agent. 执行： 1$ exec ssh-agent bash 接下来添加刚才创建的ssh key的私钥： 123456789//第一个$ ssh-add ~/.ssh/id_rsa_githubEnter passphrase for /Users/XXX/.ssh/id_rsa_github: Identity added: /Users/XXX/.ssh/id_rsa_github (/Users/XXX/.ssh/id_rsa_github)//第二个$ ssh-add ~/.ssh/id_rsa_giteeEnter passphrase for /Users/XXX/.ssh/id_rsa_gitee: Identity added: /Users/XXX/.ssh/id_rsa_gitee (/Users/XXX/.ssh/id_rsa_gitee) 1.3.添加公钥其实就是将对应的.pub中的内容，复制到对应平台的ssh key管理栏目中，不同的平台，位置不同，可以去对应的个人中心的设置中查看，很容易找到。 1.4.配置文件config在/.ssh目录下创建config配置文件： 1$ vim ~/.ssh/config 熟悉vim的可以直接在终端中编辑这个config文件，不熟悉的，打开指定目录下新创建的config文件，直接文本编辑即可： 1234567891011# github配置Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_github# gitee配置Host gitee.com HostName gitee.com User git IdentityFile ~/.ssh/id_rsa_gitee 编辑保存后，再次查看ssh key的代理： 1$ ssh-add -l 如果看到如下，说明设置成功了： 122048 SHA256:............ /Users/XXX/.ssh/id_rsa_github (RSA)2048 SHA256:............ /Users/XXX/.ssh/id_rsa_gitee (RSA) 1.5.验证ssh key终端中输入如下验证命令，如果返回如下，说明配置成功了： 12345$ ssh -T git@github.comHi XXXXXX! You've successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@gitee.comHi XXXXXX! You've successfully authenticated, but Gitee.com does not provide shell access. 如果遇到： 1permission denied (publickey) 就是之前的公钥设置的问题，需要去对应的平台检查下ssh key公钥是否设置成功。至此，ssh key的配置管理就结束了。 2.多个git账户的提交问题我们大多数人都会使用第三方工具进行git提交，比如source tree之类的，这些工具在提交时，如果不对对应的git仓库进行专门的配置，会默认走git的全局配置，也就是会用默认的全局配置的账户进行git提交。一不小心，就会用我们私人的账户，进行了公司项目的git提交，生成了对应的提交记录，也有可能因为权限问题，导致直接提交失败。这时，我们需要对不同的仓库，进行对应的配置。 2.1.检查全局配置在终端中，分别输入如下命令，可以检查目前电脑中的git的全局配置信息，如果没有返回，说明没有全局配置，如果有，就可以看到对应的默认的账户是那个了。 12$ git config --global user.name$ git config --global user.email 为了避免麻烦，我们可以取消全局配置： 12$ git config --global --unset user.name$ git config --global --unset user.email 2.2.全局配置和局部配置此时已经取消了电脑中默认的git全局配置信息，此时进行git提交，会报对应的找不到账户信息的错误。我们可以cd到对应的git仓库的根目录下，执行局部git配置命令。比如/Users/XXX/github/DemoProject是一个在github平台托管的本地git仓库的根目录，我们可以执行如下命令： 123$ cd /Users/XXX/github/DemoProject$ git config user.name$ git config user.email 如果返回均为空，说明没有进行过局部配置，可以分别配置github的账户名和邮箱： 12$ git config user.name "github账户名"$ git config user.email "github@example.com" 同理，在不同的git仓库下，可以分别配置不同平台的git账户名和git邮箱。这虽然看起来麻烦，不过，只要设置完成，之后只要不再更改对应的git仓库的路径，就不需要再更换配置了。而且，即便我们没有取消默认的全局git配置，在进行了局部配置后，后者的优先级会更高。 执行： 1$ git config --list 可以查看查看当前仓库的具体配置信息，在当前仓库目录下查看的配置是全局配置+当前项目的局部配置，使用的时候会优先使用当前仓库的局部配置，如果没有，才会去读取全局配置。 2.3.hexo部署时的git提交问题因为我们先前取消了电脑中的git全局配置，hexo在部署发布时，可能遇到如下问题： 123456789*** Please tell me who you are.Run git config --global user.email "you@example.com" git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository. 不知道是不是因为hexo必须要求读取全局配置，设置了几个文件夹的局部git配置，均无效，只好又恢复了全局配置，也就是对应的github的账户信息，因为之前提到过，局部配置的优先级大于全局配置，所以不用担心账户冲突的问题，只要设置好对应仓库的局部配置信息，就不用担心全局配置的存在。当然，这只是折中的方案，如果有人知道如何配置hexo仓库的局部配置信息，欢迎指教。 参考 一台电脑如何管理多个SSH KEY 同一台电脑关于多个SSH KEY管理 Git管理多个SSH密钥，Git多帐号配置 如何配置多个ssh key Git配置多账号登录不同项目 Git全局配置和单个仓库的用户名邮箱配置 GIT 常用命令 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/02/一台电脑管理多个Git账户和SSH-KEY/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SSH KEY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods中PBXSourcesBuildPhase unknown UUID的错误解决]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F01%2FCocoaPods%E4%B8%ADPBXSourcesBuildPhase-unknown-UUID%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Tips在执行pod install命令时，出现了如下的警告：12345[!] `&lt;PBXResourcesBuildPhase UUID=`XXX`&gt;` attempted to initialize an object with an unknown UUID. `XXX` for attribute: `files`. This can be the result of a merge and the unknown UUID is being discarded. 解决方式如下： 1.打开项目-&gt;Target-&gt;General-&gt;Linked Frameworks and Libraries，选中libpods-XXX.a，XXX是指你的项目名称，点“-”删除。 2.退出Xcode 3.重新执行pod install 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中PBXSourcesBuildPhase-unknown-UUID的错误解决/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods中的Smart quotes were detected...警告]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2F01%2FCocoaPods%E4%B8%AD%E7%9A%84Smart-quotes-were-detected-%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Tips在执行pod install命令时，出现了如下的警告：12345[!] Smart quotes were detected and ignored in your Podfile. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice. 大致的意思是：在Podfile文件中，引号被智能的检测到并被忽略。 通过检查Podfile文件，发现了如下代码： 1target 'Demo’ do 这明显是因为输入法切换导致的右引号写成了中文的单引号，这个问题很难被发现，即便没什么影响，但是改一下就可以消除警告，何乐为不为： 1target 'Demo' do 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/08/01/CocoaPods中的Smart-quotes-were-detected-警告/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发Tips</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIViewController继承时父子类方法重名造成的一个crash]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F31%2FUIViewController%E7%BB%A7%E6%89%BF%E6%97%B6%E7%88%B6%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%B8%AAcrash%2F</url>
    <content type="text"><![CDATA[前言最近在开发过程中，遇到了一个因为UIViewController继承时父子类方法重名造成的一个crash问题，本文是问题的原因分析和解决方法。 内容1.一个crash问题的分析有如下父子类，SubViewController继承于BaseViewController，父子类中均有-addConstraintsForSubviews这个重名的私有方法。 1234567891011121314151617181920212223//父类@implementation BaseViewController- (void)viewDidLoad&#123; [super viewDidLoad]; //添加子视图 [self base_lazyLoadSubviews]; //添加约束 [self addConstraintsForSubviews];&#125;@end//子类@implementation SubViewController- (void)viewDidLoad&#123; [super viewDidLoad]; //添加子视图 [self sub_lazyLoadSubviews]; //添加约束 [self addConstraintsForSubviews];&#125;@end 实际运行过程中，遇到了如下的crash： 12345678910Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;NSLayoutConstraint for &lt;UIImageView: 0x10bee7fa0; frame = (0 0; 0 0); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17023ba00&gt;&gt;: A multiplier of 0 or a nil second item together with a location for the first attribute creates an illegal constraint of a location equal to a constant. Location attributes must be specified in pairs.&apos; 上述的-addConstraintsForSubviews方法中有用到AutoLayout做自动布局，crash也是因为自动布局导致的。经过断点调试，也就是走了一遍ViewController的生命周期方法，分析出了这个crash的原因： 1.子类执行-viewDidLoad时，调用了[super viewDidLoad]，触发父类的-viewDidLoad。 2.父类的-viewDidLoad方法中实现了基础的UI加载和布局，也就是父类对应的-base_lazyLoadSubviews和-addConstraintsForSubviews这两个方法。 3.当父类执行这两个方法时，其实就已经有问题了，因为子类有同名的-addConstraintsForSubviews方法，导致父类的方法实现被子类覆盖了，此时父类会去调用子类的-addConstraintsForSubviews去布局。 4.子类此时还没有执行-sub_lazyLoadSubviews方法，也就是子类的视图控件还没有添加到父视图上，此时执行AutoLayout，就造成了crash。 2.解决方法在父类增加一些共有的UI组件，某些情况下可以简化开发，但其实更多的时候，并没有省却很多麻烦。个人建议还是不要在公有的父类中增加过多的UI特性，以免日后更多的不必要的麻烦，子类过多，已经足够引起你的重视了。当然如果只是项目中的基类，用作埋点或其他用途，那么增加其他的UI特性，更是不合适的了。下面只是基于上述问题，提出对应的解决方案。 2.1.规范命名这其实是算是一个命名不规范导致的问题，如果是父类私有的方法，还是增加前缀比较安全，所以最简单的解决方式就是改名：-base_addConstraintsForSubviews-sub_addConstraintsForSubviews 2.2.更加优雅的解决方式上一种方法其实并不是很好，因为可能遇到其他开发者继承于你的父类的问题，如果每次都要告知对方去注意这些问题，就很容易出问题了。这里提出一种参考系统的生命周期方法中回调父类的方式去解决这个问题。在父类中的头文件，声明子类容易覆写的同类型方法： 1234@interface BaseViewController : UIViewController- (void)lazyLoadSubviews NS_REQUIRES_SUPER;- (void)addConstraintsForSubviews NS_REQUIRES_SUPER;@end 方法声明过程中，使用了系统的宏NS_REQUIRES_SUPER来修饰，表示子类覆写该方法时，必须在方法内部调用super的这个方法，否则会有如下的警告（以系统的UITableViewCell的-prepareForReuse方法为例）： 这样即便子类使用者在不知情的情况下，覆写了父类的同名方法，也会有警告提示，只要执行了父类的同名方法，就可以避免上述的问题发生。 参考 iOS 修饰符~ NS_UNAVAILABLE、NS_REQUIRES_SUPER NS_REQUIRES_SUPER 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/07/31/UIViewController继承时父子类方法重名造成的一个crash/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>iOS</category>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F30%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍了在Mac环境下，通过Hexo+Github搭建个人博客的完整操作流程，笔者参考了部分现有的文章，通过实践，排除了一些坑，并多次尝试后，整理出本文。 步骤1.安装Node.js通过Homebrew安装，会很便捷，但是事后遇到了重启终端，执行nvm命令，报-bash: npm: command not found错误，只好重头做起，在Node.js官网下载包安装，也很方便。5分钟 搭建免费个人博客一文中提到的，使用Homebrew安装Node.js的命令如下，请注意其中的注释： 12345$ brew install nvm$ mkdir ~/.nvm$ export NVM_DIR=~/.nvm$ . $(brew --prefix nvm)/nvm.sh$ nvm install 4 //这里是大坑，这个指定了安装的版本，截止到本文书写时，node的版本已经到8.x了 个人建议还是直接去官网下载包安装。 2.安装Git这个是提交之后的内容必备的，Mac自带了git，就不再赘述。 3.安装Hexo终端命令如下（Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时要在前面加上sudo，否则会因为权限问题报错）： 1$ sudo npm install -g hexo 4.初始化Hexo终端cd到自己选定的一个文件夹（之后所有的hexo相关的文件都将安装在文件夹中）的上一层级目录（选定的文件夹包含于该层级下），执行hexo init命令： 12$ cd /Users/...$ hexo init XXX //XXX是对应的自己建立的文件夹的名字，用于存放之后关于hexo的所有文件 cd到XXX文件夹下，安装npm： 12$ cd XXX$ npm install 5.测试hexo执行命令，开启hexo： 1$ hexo s 执行命令后，在浏览器中访问：http://localhost:4000/看到下面的页面，说明本地访问成功，hexo的初始化工作结束： 执行下面的命令可以停止测试。 1$ Ctrl+C 6.建立Github关联的仓库在github新建一个仓库，仓库名固定为github用户名.github.io。 例如笔者的就是：kukumaluCN.github.io 获取到仓库的地址和git地址，后面使用。 7.配置_config.yml文件在之前的XXX文件夹下，有_config.yml文件，该文件是hexo的配置信息，因为不同版本，该文件的信息会有变化，所以网上的很多教程都不太适用，需要自己综合参考修改，下面的是根据笔者当前的配置列出的示例。 需要修改的基本信息如下，如果有其他需要，可以参考官网Hexo配置自行修改（注意冒号后面必须有空格）： 123456789101112131415161718# Sitetitle: 霖溦之境 #Hexo 博客标题subtitle: 霖溦的个人博客 #博客副标题description: 霖溦的个人博客author: 霖溦 #作者名language: zh-Hans #中文# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://github.com/kukumaluCN/kukumaluCN.github.io #github仓库的地址root: /# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址branch: master 8.安装hexo-deployer-git自动部署发布工具执行命令： 1$ npm install hexo-deployer-git --save 9.发布hexo修改完上述配置后，可以再次hexo s执行一次测试，看看修改后的效果。没有问题就可以发布了。 在XXX文件夹下生成静态页面，执行： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 这是三个命令，clean是清理缓存，g就是generate生成静态文件，d是deploy也就是最终的部署。 具体的命令参考官网：Hexo指令 执行上述命令时，可能因为没有关联github提示输入github的用户名和密码（参考第10条，可能是deploy中repo的设置问题，改成ssh就不会遇到该提示了，前提是你的github绑定了ssh key）。 10.发布文章cd到XXX目录下，执行命令： 1$ hexo new "title" //title是要发布的文章的标题 title是要发布的文章的标题，具体规范参考Hexo指令中关于new的一项。 执行之后，会在/XXX/source/_posts路径下生成“title.md”文件，具体的书写就是标准的markdown语法了，可以自行使用习惯的md编辑器书写。 文章编辑完之后执行如下命令发布： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 期间遇到了如下错误： 123remote: Invalid username or password.fatal: Authentication failed for &apos;https://github.com/kukumaluCN/kukumaluCN.github.io.git/&apos;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html 本以为是SSH key的问题，结果发现设置过了，经过实验，发现是配置文件的问题： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: git#repo: https://github.com/kukumaluCN/kukumaluCN.github.io.git #github仓库的git地址repo: git@github.com:kukumaluCN/kukumaluCN.github.io.git #改成ssh地址branch: master 11.更换主题Hexo的主题有很多，具体参考：Thems这里以maupassant主题为例：cd XXX到刚才的目录。执行如下命令： 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 再次修改配置文件_config.yml，将theme的值改为maupassant。编辑完之后执行如下命令发布： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 参考 5分钟 搭建免费个人博客 Mac上搭建基于GitHub的Hexo博客 如何搭建自己的博客 本文作者： 霖溦本文链接： https://kukumalucn.github.io/blog/2018/07/30/Hexo-Github搭建个人博客/版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>技术博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于霖溦之境]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F27%2F%E5%85%B3%E4%BA%8E%E9%9C%96%E6%BA%A6%E4%B9%8B%E5%A2%83%2F</url>
    <content type="text"><![CDATA[这里是霖溦的个人博客，从今天开始将在这里陆续更新博文，博文内容不限于iOS开发技术，也包含个人爱好的点滴。 写于 2018.7.27 本文作者：霖溦本文链接：https://kukumalucn.github.io/blog/2018/07/27/关于霖溦之境/版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>随笔</category>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
</search>
